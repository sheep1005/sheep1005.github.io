<!DOCTYPE html>
<html>
	<head>
		
<title>Web Apis-hi</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="前端,学习笔记,Web Apis,">
<meta name="description" content="很重~要~的哦">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.highlightAll();</script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>sheep</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 66%;
        height: 100%;
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815);
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					right: "0"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					right: "-100%"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-color"
    style="background: url('')" 
>
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
            
            <li><a href="/tags/前端">前端</a></li>
            
            <li><a href="/tags/学习笔记">学习笔记</a></li>
            
            <li><a href="/tags/Web Apis">Web Apis</a></li>
            
            
        </ul>
        
        <h1>Web Apis</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                        <g>
                            <path fill="#12183A"
                                d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                            </path>
                        </g>
                    </svg>
                
                <span class="post-header-info-author-text"> <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">Sheep</a></span>
                <div class="post-header-info-author-categories">
                    
                         <a href="../../categories/Web-Apis/" target="_blank" >Web Apis</a>
                    
                </div>
                <p>2022-11-11 20:33:36</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h1 id="Web-APIs"><a href="#Web-APIs" class="headerlink" title="Web APIs"></a>Web APIs</h1><h2 id="1-Web-APIs-和-JS-基础关联性"><a href="#1-Web-APIs-和-JS-基础关联性" class="headerlink" title="1. Web APIs 和 JS 基础关联性"></a>1. Web APIs 和 JS 基础关联性</h2><ul>
<li>Web APIs 是 JS 的应用，大量使用 JS 基础语法做交互效果</li>
</ul>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/JS%E7%9A%84%E7%BB%84%E6%88%90.png"></p>
<h2 id="2-API-和Web-API"><a href="#2-API-和Web-API" class="headerlink" title="2. API 和Web API"></a>2. API 和Web API</h2><ul>
<li>API （&#x3D;&#x3D;应用程序编程接口&#x3D;&#x3D;）一般是一些&#x3D;&#x3D;预定义的函数&#x3D;&#x3D;，是给程序员提供的一种工具，以便更轻松实现功能</li>
<li>&#x3D;&#x3D;Web API 是浏览器&#x3D;&#x3D;提供的一套操作&#x3D;&#x3D;浏览器功能&#x3D;&#x3D;和&#x3D;&#x3D;页面元素&#x3D;&#x3D;的&#x3D;&#x3D;API&#x3D;&#x3D;(BOM  和 BOM)，主要针对浏览器做交互效果</li>
<li>Web API 一般都有输入和输出（函数的传参和返回值），Web API 很对都是方法（函数）</li>
</ul>
<h2 id="3-DOM"><a href="#3-DOM" class="headerlink" title="3. DOM"></a>3. DOM</h2><h3 id="3-1-DOM-简介"><a href="#3-1-DOM-简介" class="headerlink" title="3.1 DOM 简介"></a>3.1 DOM 简介</h3><ul>
<li><p>文档对象模型（&#x3D;&#x3D;DOM&#x3D;&#x3D;)，处理可标记语言（HTML ， XML）的&#x3D;&#x3D;编程接口&#x3D;&#x3D;</p>
</li>
<li><p>可以改变网页的&#x3D;&#x3D;内容、结构和样式&#x3D;&#x3D;</p>
</li>
<li><p>DOM 树</p>
<blockquote>
<p>&#x3D;&#x3D;DOM 把以下内容都看作是对象&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>文档：一个页面就是一个文档，DOM 中用 document 表示</p>
</li>
<li><p>元素：页面中的所有标签都是元素，DOM 中用 element 表示</p>
</li>
<li><p>节点：网页中所有内容都是节点（标签、属性、文本、注释等）DOM 中用 node 表示</p>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/DOM%E6%A0%91.png"></p>
</li>
</ul>
</li>
</ul>
<h3 id="3-2-获取元素"><a href="#3-2-获取元素" class="headerlink" title="3.2 获取元素"></a>3.2 获取元素</h3><h4 id="3-2-1-根据-ID-获取"><a href="#3-2-1-根据-ID-获取" class="headerlink" title="3.2.1 根据 ID 获取"></a>3.2.1 根据 ID 获取</h4><ul>
<li><p><strong>getElementById(id)</strong></p>
<pre><code class="javascript">let element = document.getElementById(id);
</code></pre>
<ul>
<li><p>&#x3D;&#x3D;返回的是一个元素对象&#x3D;&#x3D;</p>
</li>
<li><p>get：获得 ；element：元素 ；by：通过 – 驼峰命名法 </p>
</li>
<li><p>参数 id 是&#x3D;&#x3D;大小写敏感&#x3D;&#x3D;的字符串</p>
</li>
<li><p>因为我们文档页面从上往下加载，所以先得有标签 所以我们script写到标签的下面</p>
</li>
<li><p>&#x3D;&#x3D;<strong>console.dir</strong>&#x3D;&#x3D; 打印我们返回的元素对象 更好的&#x3D;&#x3D;查看里面的属性和方法&#x3D;&#x3D;</p>
<pre><code class="html">&lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;

&lt;script&gt;
    let timer = document.getElementById(&#39;time&#39;);
    console.log(timer);// &lt;div id=&quot;time&quot;&gt;2019-9-9&lt;/div&gt;
    console.log(typeof timer);// Object
    console.dir(timer);// time 的属性和方法
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-2-根据标签名获取"><a href="#3-2-2-根据标签名获取" class="headerlink" title="3.2.2 根据标签名获取"></a>3.2.2 根据标签名获取</h4><ul>
<li><p>getElementsByTagName(标签名)</p>
<pre><code class="javascript">let lis = document.getElementsByTagName(&#39;标签名&#39;);
</code></pre>
<ul>
<li><p>返回的是带有指定标签名的&#x3D;&#x3D;对象的集合&#x3D;&#x3D;，以&#x3D;&#x3D;伪数组的形式存储&#x3D;&#x3D;的</p>
<pre><code class="javascript">        console.log(lis);
        console.log(lis[0]);
</code></pre>
</li>
<li><p>得到的元素是动态的</p>
</li>
<li><p>我们想要依次打印里面的元素对象我们可以采取遍历的方式</p>
<pre><code class="html">for (let i = 0; i &lt; lis.length; i++) &#123;
    console.log(lis[i]);
&#125;
</code></pre>
</li>
<li><p>如果页面中只有一个li 返回的还是伪数组的形式 </p>
</li>
<li><p>如果页面中没有这个元素 返回的是空的伪数组的形式</p>
</li>
<li><p>&#x3D;&#x3D;element.getElementsByTagName(‘标签名’);&#x3D;&#x3D;父元素必须是&#x3D;&#x3D;指定的单个元素&#x3D;&#x3D;，获取的时候不包括父元素自己</p>
<pre><code class="javascript">let ol = document.getElementById(&#39;ol&#39;);     
console.log(ol.getElementsByTagName(&#39;li&#39;));
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-2-3-通过-HTML5-新增的方法获取"><a href="#3-2-3-通过-HTML5-新增的方法获取" class="headerlink" title="3.2.3 通过 HTML5 新增的方法获取"></a>3.2.3 通过 HTML5 新增的方法获取</h4><h5 id="（1）getElementsByClassName-类名"><a href="#（1）getElementsByClassName-类名" class="headerlink" title="（1）getElementsByClassName(类名)"></a>（1）getElementsByClassName(类名)</h5><ul>
<li><p>根据类名获得某些元素集合</p>
<pre><code class="javascript">let boxs = document.getElementsByClassName(&#39;box&#39;);
console.log(boxs);
</code></pre>
</li>
</ul>
<h5 id="（2）querySelector"><a href="#（2）querySelector" class="headerlink" title="（2）querySelector()"></a>（2）querySelector()</h5><ul>
<li><p>返回指定选择器的第一个元素对象</p>
<ul>
<li><p>返回指定选择器的&#x3D;&#x3D;第一个元素对象&#x3D;&#x3D;  切记 里面的选择器&#x3D;&#x3D;需要加符号&#x3D;&#x3D;</p>
<ul>
<li>querySelector(‘.类名’)</li>
<li>querySelector(‘#ID名’)</li>
<li>querySelector(‘标签名’)</li>
</ul>
<pre><code class="javascript">let firstBox = document.querySelector(&#39;.box&#39;);
console.log(firstBox);
let nav = document.querySelector(&#39;#nav&#39;);
console.log(nav);
var li = document.querySelector(&#39;li&#39;);
console.log(li);
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（3）querySelectorAll"><a href="#（3）querySelectorAll" class="headerlink" title="（3）querySelectorAll()"></a>（3）querySelectorAll()</h5><ul>
<li>返回指定选择器的所有元素对象集合</li>
</ul>
<h4 id="3-2-4-获取特殊元素"><a href="#3-2-4-获取特殊元素" class="headerlink" title="3.2.4 获取特殊元素"></a>3.2.4 获取特殊元素</h4><h5 id="（1）获取-body-标签"><a href="#（1）获取-body-标签" class="headerlink" title="（1）获取 body 标签"></a>（1）获取 body 标签</h5><pre><code class="javascript">let bodyEle = document.body;
console.log(bodyEle);// 元素
console.dir(bodyEle);// 属性方法
</code></pre>
<h5 id="（2）获取-head-标签"><a href="#（2）获取-head-标签" class="headerlink" title="（2）获取 head 标签"></a>（2）获取 head 标签</h5><pre><code class="javascript">let htmlEle = document.documentElement;
console.log(htmlEle);
</code></pre>
<h3 id="3-3-事件基础"><a href="#3-3-事件基础" class="headerlink" title="3.3 事件基础"></a>3.3 事件基础</h3><h5 id="3-3-1-事件概述"><a href="#3-3-1-事件概述" class="headerlink" title="3.3.1 事件概述"></a>3.3.1 事件概述</h5><ul>
<li>JS 使我们有能力创建动态页面，而&#x3D;&#x3D;事件是&#x3D;&#x3D;可以被  JavaScript 侦测到的&#x3D;&#x3D;行为&#x3D;&#x3D;，触发相应的一种机制</li>
</ul>
<h5 id="3-3-2-事件三要素（执行时间的步骤）"><a href="#3-3-2-事件三要素（执行时间的步骤）" class="headerlink" title="3.3.2 事件三要素（执行时间的步骤）"></a>3.3.2 事件三要素（执行时间的步骤）</h5><ul>
<li><p>事件源（事件被触发的对象）</p>
<ul>
<li>获得事件对象</li>
</ul>
<pre><code class="javascript">let btn = document.getElementById(&#39;btn&#39;);
</code></pre>
</li>
<li><p>事件类型（如何触发 什么事件 比如鼠标点击(onclick) 还是鼠标经过 还是键盘按下）</p>
</li>
<li><p>事件处理程序</p>
<ul>
<li><p>通过一个&#x3D;&#x3D;函数赋值的方式&#x3D;&#x3D;完成</p>
<pre><code class="javascript">btn.onclick = function() &#123;
    alert(&#39;点秋香&#39;);
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="3-3-3-常见的鼠标事件"><a href="#3-3-3-常见的鼠标事件" class="headerlink" title="3.3.3 常见的鼠标事件"></a>3.3.3 常见的鼠标事件</h5><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6.png"></p>
<h3 id="3-4-操作元素"><a href="#3-4-操作元素" class="headerlink" title="3.4 操作元素"></a>3.4 操作元素</h3><h4 id="3-4-1-改变元素内容"><a href="#3-4-1-改变元素内容" class="headerlink" title="3.4.1 改变元素内容"></a>3.4.1 改变元素内容</h4><h6 id="（1）innerText"><a href="#（1）innerText" class="headerlink" title="（1）innerText"></a>（1）innerText</h6><blockquote>
<p>替换从开始到终止位置的内容，但他去除 html 标签，同时空格和换行也会去掉</p>
</blockquote>
<ul>
<li><p>获取元素</p>
<pre><code class="javascript">let btn = document.querySelector(&#39;button&#39;);
let div = document.querySelector(&#39;div&#39;);
let p = document.querySelector(&#39;p&#39;);
</code></pre>
</li>
<li><p>注册事件（元素可以不添加事件）</p>
<pre><code class="javascript">btn.onclick = function()&#123;
    // div.innerText = &#39;2019-6-6&#39;;
    div.innerText = getDate();// JS 基础中封装的函数
&#125;
// 元素可以不添加事件
p.innerText = getDate();
</code></pre>
</li>
</ul>
<h6 id="（2）-x3D-x3D-innerHTML-x3D-x3D"><a href="#（2）-x3D-x3D-innerHTML-x3D-x3D" class="headerlink" title="（2）&#x3D;&#x3D;innerHTML&#x3D;&#x3D;"></a>（2）&#x3D;&#x3D;innerHTML&#x3D;&#x3D;</h6><blockquote>
<p>替换从开始到终止位置的内容，保留 html 标签，同时也保留空格和换行</p>
</blockquote>
<h6 id="（3）innerText-和-x3D-x3D-innerHTML-x3D-x3D-的区别"><a href="#（3）innerText-和-x3D-x3D-innerHTML-x3D-x3D-的区别" class="headerlink" title="（3）innerText 和 &#x3D;&#x3D;innerHTML&#x3D;&#x3D; 的区别"></a>（3）innerText 和 &#x3D;&#x3D;innerHTML&#x3D;&#x3D; 的区别</h6><ul>
<li><p>innerText 不识别html标签，同时空格和换行也会去掉</p>
<pre><code class="html">div.innerText = &#39;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#39;;//
</code></pre>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/innerText.png"></p>
</li>
<li><p>innerHTML 识别html标签，同时也保留空格和换行</p>
<pre><code class="html">div.innerText = &#39;&lt;strong&gt;今天是：&lt;/strong&gt; 2019&#39;;//
</code></pre>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/innerHTML.png"></p>
</li>
</ul>
<h4 id="3-4-2-操作常见元素属性"><a href="#3-4-2-操作常见元素属性" class="headerlink" title="3.4.2 操作常见元素属性"></a>3.4.2 操作常见元素属性</h4><blockquote>
<p>格式：&#x3D;&#x3D;元素.属性&#x3D; ‘ ‘&#x3D;&#x3D;</p>
<p>常用的元素属性</p>
<ul>
<li>src、href</li>
<li>id、alt、title</li>
</ul>
</blockquote>
<ul>
<li><p>获取元素</p>
<pre><code class="javascript">let ldh = document.getElementById(&#39;ldh&#39;);
let zxy = document.getElementById(&#39;zxy&#39;);
let img = document.querySelector(&#39;img&#39;);
</code></pre>
</li>
<li><p>注册事件  处理程序</p>
<pre><code class="javascript">zxy.onclick = function() &#123;
    img.src = &#39;images/zxy.jpg&#39;;
    img.title = &#39;张学友思密达&#39;;
&#125;
ldh.onclick = function() &#123;
    img.src = &#39;images/ldh.jpg&#39;;
    img.title = &#39;刘德华&#39;;
&#125;
</code></pre>
</li>
</ul>
<h4 id="3-4-3-操作表单元素属性"><a href="#3-4-3-操作表单元素属性" class="headerlink" title="3.4.3 操作表单元素属性"></a>3.4.3 操作表单元素属性</h4><blockquote>
<p>常用的表单元素属性：</p>
<ul>
<li>type、value、checked、selected、disabled</li>
</ul>
</blockquote>
<ul>
<li><p>获取元素</p>
<pre><code class="javascript">let btn = document.querySelector(&#39;button&#39;);
let input = document.querySelector(&#39;input&#39;);
</code></pre>
</li>
<li><p>注册事件 处理程序</p>
<ul>
<li><p>&#x3D;&#x3D;表单里面的值&#x3D;&#x3D; 文字内容是通过 &#x3D;&#x3D;value&#x3D;&#x3D; 来修改的</p>
<pre><code class="javascript">btn.onclick = function() &#123;
    input.value = &#39;被点击了&#39;;
&#125;
</code></pre>
</li>
<li><p>如果想要某个表单&#x3D;&#x3D;被禁用&#x3D;&#x3D; 不能再点击用 &#x3D;&#x3D;disabled&#x3D;&#x3D;</p>
<pre><code class="javascript">this.disabled = true;// this 指向的是事件函数的调用者 btn
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-4-操作元素样式属性"><a href="#3-4-4-操作元素样式属性" class="headerlink" title="3.4.4 操作元素样式属性"></a>3.4.4 操作元素样式属性</h4><blockquote>
<p>我们可以通过 JS 修改元素的大小、颜色、位置等样式</p>
</blockquote>
<ul>
<li><p>element&#x3D;&#x3D;.style&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;行内样式&#x3D;&#x3D;：适合于样式较少的情况，CSS权重比较高</p>
</li>
<li><p>获取元素</p>
<pre><code class="javascript">let div = document.querySelector(&#39;div&#39;)
</code></pre>
</li>
<li><p>注册事件 处理程序</p>
<pre><code class="javascript">div.onclick = function() &#123;
    //div.style
    this.style.backgroundColor = &#39;purple&#39;;//点击修改颜色
    this.style.width = &#39;250px&#39;;//修改宽度
    this.style.display = &#39;none&#39;;//点击隐藏
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>element.className</p>
<ul>
<li><p>&#x3D;&#x3D;类名样式&#x3D;&#x3D;：className更改元素的样式 适合于样式较多或者功能复杂的情况</p>
</li>
<li><p>className 会直接更改、覆盖原来的类名</p>
<blockquote>
<p>&#x3D;&#x3D;如果想要保留原先的类名，可以在原来的类名后面加上空格和新的类名（多类名选择器）&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p>在 CSS 中 写一个 .change 样式</p>
<pre><code class="css">.change &#123;
    background-color: purple;
    color: #fff;
    font-size: 25px;
    margin-top: 100px;
&#125;
</code></pre>
</li>
<li><p>获取元素 注册事件 处理程序</p>
<pre><code class="html">&lt;div class=&quot;first&quot;&gt;文本&lt;/div&gt;
&lt;script&gt;
var test = document.querySelector(&#39;div&#39;);
test.onclick = function() &#123;
    this.className = &#39;first change&#39;;// 多类名选择器
&#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-4-6-排他思想"><a href="#3-4-6-排他思想" class="headerlink" title="3.4.6 排他思想"></a>3.4.6 排他思想</h4><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E6%8E%92%E4%BB%96%E6%80%9D%E6%83%B3.png"></p>
<p>如果有同一组元素，我们想要某一个元素实现某种样式，需要用到循环的排他思想算法：</p>
<ul>
<li>所有元素全部清除样式</li>
<li>给当前元素设置样式</li>
<li>注意顺序不能颠倒，先干掉其他人，再设置自己</li>
</ul>
<pre><code class="html">&lt;button&gt;按钮1&lt;/button&gt;
&lt;button&gt;按钮2&lt;/button&gt;
&lt;button&gt;按钮3&lt;/button&gt;
&lt;button&gt;按钮4&lt;/button&gt;
&lt;button&gt;按钮5&lt;/button&gt;
&lt;script&gt;
    //1.获取所有元素
    let btns = document.querySelectorAll(&#39;button&#39;);
    // btns 得到的是伪数组 里面的每一个元素 btns[i]
    for(let i = 0; i &lt; btns.length; i++) &#123;
        btns[i].onclick = function() &#123;
            // （1）我们先把所有的按钮背景颜色全部去掉
            for(let j = 0; j &lt; btns.length; j++) &#123;
                    btns[j].style.backgroundColor = &#39;&#39;;
            &#125;
            // （2）然后再把选中的按钮背景颜色改为粉色
            this.style.backgroundColor = &#39;pink&#39;;
        &#125;
    &#125;

&lt;/script&gt;
</code></pre>
<h4 id="3-4-7-自定义属性的操作"><a href="#3-4-7-自定义属性的操作" class="headerlink" title="3.4.7 自定义属性的操作"></a>3.4.7 自定义属性的操作</h4><blockquote>
<p>自定义属性的目的：为了保存并使用一些不用保存在数据库中直接保存在页面中的数据。</p>
</blockquote>
<h5 id="（1）获取属性值"><a href="#（1）获取属性值" class="headerlink" title="（1）获取属性值"></a>（1）获取属性值</h5><ul>
<li><p>element.属性</p>
<ul>
<li>获取&#x3D;&#x3D;内置&#x3D;&#x3D;属性值（元素本身自带的）</li>
</ul>
<pre><code class="html">&lt;div id=&quot;box&quot; index=&quot;1&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    let box = document.querySelector(&#39;div&#39;);
    // 打印box属性值 id
    console.log(div.id);
&lt;/script&gt;
</code></pre>
</li>
<li><p>获取自定义属性</p>
<ul>
<li><p>兼容性获取 &#x3D;&#x3D;element.getAttribute(‘data-index’)&#x3D;&#x3D;</p>
<ul>
<li>主要获取我们自己添加&#x3D;&#x3D;自定义&#x3D;&#x3D;的属性值(index)</li>
</ul>
<pre><code class="javascript">// 打印box属性值 index
console.log(div.getAttribute(&#39;data-index&#39;));
</code></pre>
</li>
<li><p>H5 新增方法 &#x3D;&#x3D;element.dataset.index&#x3D;&#x3D; 或 &#x3D;&#x3D;element.dataset[‘index’]&#x3D;&#x3D;</p>
<ul>
<li><p>&#x3D;&#x3D;它只能获取 data- 开头的&#x3D;&#x3D;</p>
</li>
<li><p>dataset 是一个集合 里面存放了所有以 data 开头的自定义属性</p>
</li>
<li><p>如果&#x3D;&#x3D;自定义属性里面有多个 -  连接&#x3D;&#x3D;的单词，我们获取的时候采取 &#x3D;&#x3D;驼峰命名法&#x3D;&#x3D;</p>
</li>
</ul>
<pre><code class="html">&lt;div id=&quot;box&quot; data-index=&quot;1&quot; data-list-name=&quot;andy&quot;&gt;&lt;/div&gt;
&lt;script&gt;
    console.log(div.dataset.index);
    console.log(div.dataset[&#39;index&#39;]);
    console.log(div.dataset.listName);
    console.log(div.dataset[&#39;listName&#39;]);
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（2）设置属性值"><a href="#（2）设置属性值" class="headerlink" title="（2）设置属性值"></a>（2）设置属性值</h5><ul>
<li><p>element.属性 &#x3D; ‘值’</p>
<ul>
<li>设置内置属性值</li>
</ul>
<pre><code class="javascript">div.id = &#39;text&#39;;
div.className = &#39;navs&#39;;// 修改类名 class
</code></pre>
</li>
<li><p>&#x3D;&#x3D;element.setAttribute(‘属性’,’值’)&#x3D;&#x3D;</p>
<ul>
<li>主要设置自定义属性</li>
<li>H5 规定自定义属性要以 &#x3D;&#x3D;data-开头&#x3D;&#x3D; 作为属性名并赋值</li>
</ul>
<pre><code class="html">&lt;div&gt;&lt;/div&gt;
&lt;script&gt;
    div.setAttribute(&#39;data-index&#39;,0);
    div.setAttribute(&#39;class&#39;,&#39;footer&#39;);// 修改类名 class
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="（3）移除属性"><a href="#（3）移除属性" class="headerlink" title="（3）移除属性"></a>（3）移除属性</h5><ul>
<li><p>element.removeAttribute(‘属性’)</p>
<pre><code class="javascript">div.removeAttribute(&#39;index&#39;)
</code></pre>
</li>
</ul>
<h3 id="3-5-节点操作"><a href="#3-5-节点操作" class="headerlink" title="3.5 节点操作"></a>3.5 节点操作</h3><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0.png"></p>
<h4 id="3-5-1-节点概述"><a href="#3-5-1-节点概述" class="headerlink" title="3.5.1 节点概述"></a>3.5.1 节点概述</h4><ul>
<li><p>网页中所有内容都是节点（&#x3D;&#x3D;标签、属性、文本、注释等&#x3D;&#x3D;）</p>
</li>
<li><p>HTML DOM 书中的所有节点均可通过 JavaScript 进行访问，所有 HTML 元素（节点）均可被修改，也可以创建或删除</p>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/DOM%E6%A0%91.png"></p>
</li>
<li><p>一般地，节点至少拥有 &#x3D;&#x3D;nodeType（节点类型）&#x3D;&#x3D;、&#x3D;&#x3D;nodeName（节点名称）&#x3D;&#x3D;、&#x3D;&#x3D;nodeValue（节点值）&#x3D;&#x3D;这三个基本属性。</p>
<ul>
<li>nodeType 的值<ul>
<li>元素节点为 1</li>
<li>属性节点为 2</li>
<li>文本节点为 3（文本节点包括文字、空格、换行等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-2-节点层级"><a href="#3-5-2-节点层级" class="headerlink" title="3.5.2 节点层级"></a>3.5.2 节点层级</h4><h5 id="（1）父级节点"><a href="#（1）父级节点" class="headerlink" title="（1）父级节点"></a>（1）父级节点</h5><ul>
<li><p>element.parentNode</p>
<ul>
<li><p>得到的是离 element 最近的父节点</p>
<pre><code class="html">&lt;div class=&quot;box&quot;&gt;
    &lt;span class=&quot;erweima&quot;&gt;×&lt;/span&gt;
&lt;/div&gt;
&lt;script&gt;
    let erweima = document.querySelector(&#39;.erweima&#39;);
    // 如果找不到父节点就返回 null
    console.log(&#39;erweima.parentNode&#39;);// 获取box
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（2）子节点"><a href="#（2）子节点" class="headerlink" title="（2）子节点"></a>（2）子节点</h5><h6 id="①-获取子节点"><a href="#①-获取子节点" class="headerlink" title="① 获取子节点"></a>① 获取子节点</h6><ul>
<li><p>parentNode.childNodes（不提倡）</p>
<ul>
<li><p>childNodes &#x3D;&#x3D;得到的所有子节点包括：元素节点、文本节点&#x3D;&#x3D;等等。如果我们只想要获得元素节点，则需要专门处理：</p>
<pre><code class="html">&lt;ul&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
    &lt;li&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    // 获取元素
    let ul = document.querySelector(&#39;ul&#39;);
    console.log(ul.childNode);
    // 只保留元素节点
    for(let i = 0; i &lt; ul.childNodes.length; i++)&#123;
        if(ul.childNodes[i].nodeType == 1) &#123;
            console.log(ul.childNodes[i]);
        &#125;
    &#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;parentNode.children&#x3D;&#x3D;</p>
<ul>
<li><p>它是一个&#x3D;&#x3D;只读属性&#x3D;&#x3D;，返回所有的子&#x3D;&#x3D;元素节点&#x3D;&#x3D;。也是我们实际开发常用的。</p>
<pre><code class="javascript">console.log(ul.children);
</code></pre>
</li>
</ul>
</li>
</ul>
<h6 id="②-获取第一个和最后一个子节点"><a href="#②-获取第一个和最后一个子节点" class="headerlink" title="② 获取第一个和最后一个子节点"></a>② 获取第一个和最后一个子节点</h6><ul>
<li><p>第一个子节点</p>
<ul>
<li><p>parentNode.firstChild：包括 文本节点 和 元素节点</p>
<pre><code class="javascript">let ul = document.querySelector(&#39;ul&#39;);
console.log(ul.firstChild);
</code></pre>
</li>
<li><p>parentNode.firstElementChild 只返回元素节点</p>
<pre><code class="javascript">console.log(ul.firstElementChild;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;parentNode.children[]&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(ul.children[0]);
</code></pre>
</li>
</ul>
</li>
<li><p>最后一个子节点</p>
<ul>
<li><p>parentNode.lastChild：包括 文本节点 和 元素节点</p>
<pre><code class="javascript">let ul = document.querySelector(&#39;ul&#39;);
console.log(ul.lastChild);
</code></pre>
</li>
<li><p>parentNode.lastElementChild 只返回元素节点</p>
<pre><code class="javascript">console.log(ul.firstElementChild;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;parentNode.children[]&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(ul.children[ul.children.length - 1]);
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（3）兄弟节点"><a href="#（3）兄弟节点" class="headerlink" title="（3）兄弟节点"></a>（3）兄弟节点</h5><ul>
<li><p>下一个兄弟节点</p>
<ul>
<li><p>node.nextSibling：包含元素节点  或者 文本节点等等</p>
<pre><code class="html">&lt;div&gt;我是div&lt;/div&gt;
&lt;span&gt;我是span&lt;/span&gt;
&lt;script&gt;
    var div = document.querySelector(&#39;div&#39;);
    console.log(div.nextSibling);
&lt;/script&gt;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;node.nextElementSibling&#x3D;&#x3D;：得到下一个兄弟元素节点</p>
<pre><code class="javascript">console.log(div.nextElementSibling);
</code></pre>
</li>
</ul>
</li>
<li><p>上一个兄弟节点</p>
<ul>
<li><p>node.previousSibling：包含元素节点  或者 文本节点等等</p>
<pre><code class="javascript">console.log(div.previousSibling);
</code></pre>
</li>
<li><p>&#x3D;&#x3D;node.previousElementSibling&#x3D;&#x3D;：得到上一个兄弟元素节点</p>
<pre><code class="javascript">console.log(div.previousElementSibling);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-3-创建节点"><a href="#3-5-3-创建节点" class="headerlink" title="3.5.3 创建节点"></a>3.5.3 创建节点</h4><blockquote>
<p>先创建 再添加位置</p>
</blockquote>
<ul>
<li><p>动态创建元素节点</p>
</li>
<li><p>&#x3D;&#x3D;document.createElement(‘tagName’);&#x3D;&#x3D;</p>
<ul>
<li>创建多个元素效率稍微低一些，但是结构更清晰</li>
</ul>
<pre><code class="javascript">let li = document.createElement(&#39;li&#39;);
</code></pre>
</li>
<li><p>document.innerHTML(‘tagName’);</p>
<ul>
<li>创建多个元素效率更高（前提是&#x3D;&#x3D;不要拼接字符串&#x3D;&#x3D;，采取数组形式拼接），结构稍微复杂</li>
</ul>
<pre><code class="javascript">let inner = document.querySelector(&#39;.inner&#39;);
inner.innerHTML = &#39;&lt;a href=&#39;#&#39;&gt;百度&lt;/a&gt;&#39;
</code></pre>
</li>
<li><p>document.write(‘tagName’);</p>
<ul>
<li>如果页面文档流加载完毕，再调用这句话会导致页面重绘</li>
</ul>
</li>
<li><p>添加节点</p>
<ul>
<li><p>node.appendChild(child) ：将 一个节点（child）&#x3D;&#x3D;追加&#x3D;&#x3D;到指定父节点（node）列表&#x3D;&#x3D;末尾&#x3D;&#x3D;</p>
</li>
<li><p>appendChild 不支持追加字符串的子元素，insertAdjacentHTML 支持追加字符串的元素</p>
<pre><code class="javascript">let ul = document.querySelector(&#39;ul&#39;);
ul.appendChild(li);
</code></pre>
</li>
<li><p>node.insertBefore(child, 指定元素)：将 一个节点（child）&#x3D;&#x3D;追加&#x3D;&#x3D;到指定&#x3D;&#x3D;子&#x3D;&#x3D;节点&#x3D;&#x3D;前面&#x3D;&#x3D;</p>
<pre><code class="javascript">let lili = document.createElement(&#39;li&#39;);
ul.insertBefore(lili, ul.children[0]);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-4-删除节点"><a href="#3-5-4-删除节点" class="headerlink" title="3.5.4 删除节点"></a>3.5.4 删除节点</h4><ul>
<li><p>node.removeChild(child)</p>
<ul>
<li><p>从 DOM 中删除一个子结点，返回删除的节点</p>
<pre><code class="javascript">let ul = document.querySelector(&#39;ul&#39;);
ul.removeChild(ul.children[0]);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-5-复制节点（克隆节点）"><a href="#3-5-5-复制节点（克隆节点）" class="headerlink" title="3.5.5 复制节点（克隆节点）"></a>3.5.5 复制节点（克隆节点）</h4><blockquote>
<p>先克隆，再添加位置</p>
</blockquote>
<ul>
<li><p>克隆指定节点</p>
<ul>
<li><p>node.cloneNode()</p>
</li>
<li><p>若&#x3D;&#x3D;括号参数&#x3D;&#x3D;为&#x3D;&#x3D;空或者为false&#x3D;&#x3D;，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点；</p>
</li>
<li><p>若想要克隆标签及内容，只需在括号里写 true ：&#x3D;&#x3D;node.cloneNode(true)&#x3D;&#x3D;</p>
<pre><code class="javascript">let ul = document.querySelector(&#39;ul&#39;);
let lili = ul.children[0].cloneNode()；
</code></pre>
</li>
</ul>
</li>
<li><p>添加节点位置</p>
<ul>
<li><p>同 3.5.3 添加节点（有两种方法）</p>
<pre><code class="javascript">ul.appendChild(lili)
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-5-6-创建并插入节点-insertAdjacentHTML"><a href="#3-5-6-创建并插入节点-insertAdjacentHTML" class="headerlink" title="3.5.6 创建并插入节点  insertAdjacentHTML()"></a>3.5.6 创建并插入节点  insertAdjacentHTML()</h4><ul>
<li><p>insertAdjacentHTML() 方法将指定的文本解析为 HTML 或 XML，并将结果节点插入到DOM树中的指定位置。它不会重新解析它正在使用的元素，因此它不会破坏元素内的现有元素。这避免了额外的序列化步骤，使其比直接使用innerHTML操作更快。</p>
</li>
<li><p>利用 insertAdjacentHTML() 可以直接把字符串格式添加到父元素中</p>
</li>
<li><p>语法：</p>
<ul>
<li><p>position 是插入的位置</p>
</li>
<li><p>text 是要被解析为 HTML 和 XML，并插入到 DOM 树中的字符串</p>
<pre><code class="javascript">element.insertAdjacentHTML(position,text);
</code></pre>
</li>
</ul>
</li>
<li><p>参数</p>
<ul>
<li>‘beforebegin’<ul>
<li>元素自身的前面</li>
</ul>
</li>
<li>‘afterbegin’<ul>
<li>插入元素内部的第一个子节点之前</li>
</ul>
</li>
<li>‘beforeend’<ul>
<li>插入元素内部的最后一个子节点之后</li>
</ul>
</li>
<li>‘afterend’<ul>
<li>元素自身的后面</li>
</ul>
</li>
</ul>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let html = &#39;&lt;div id=&quot;two&quot;&gt;two&lt;/div&gt;&#39;;
div.insertAdjacentHTML(&#39;beforeend&#39;,html);
</code></pre>
</li>
</ul>
<h3 id="3-6-事件高级"><a href="#3-6-事件高级" class="headerlink" title="3.6 事件高级"></a>3.6 事件高级</h3><h4 id="3-6-1-注册事件（绑定事件）"><a href="#3-6-1-注册事件（绑定事件）" class="headerlink" title="3.6.1 注册事件（绑定事件）"></a>3.6.1 注册事件（绑定事件）</h4><blockquote>
<p>给元素添加事件，称为注册事件。</p>
<p>注册事件有两种方式：&#x3D;&#x3D;传统方式和方法监听注册方式&#x3D;&#x3D;</p>
</blockquote>
<h5 id="（1）传统注册方式"><a href="#（1）传统注册方式" class="headerlink" title="（1）传统注册方式"></a>（1）传统注册方式</h5><ul>
<li><p>利用 on 开头的事件 </p>
</li>
<li><p>&#x3D;&#x3D;特点&#x3D;&#x3D;：注册事件的&#x3D;&#x3D;唯一性&#x3D;&#x3D;：同一个元素同一个事件只能执行一次</p>
<pre><code class="html">&lt;button onclick=&quot;alert(&#39;hi~&#39;)&quot;&gt;&lt;/button&gt;
&lt;script&gt;
    btn.onclick = function()&#123;
    alert(&#39;hi~&#39;)
    &#125;
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="（2）方法监听注册方式"><a href="#（2）方法监听注册方式" class="headerlink" title="（2）方法监听注册方式"></a>（2）方法监听注册方式</h5><ul>
<li><p>w3c 标准 &#x3D;&#x3D;推荐&#x3D;&#x3D;方式</p>
</li>
<li><p>&#x3D;&#x3D;特点&#x3D;&#x3D;：同一个元素同一个事件可以注册&#x3D;&#x3D;多个&#x3D;&#x3D;监听器，按照注册顺序&#x3D;&#x3D;依次执行&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;addEventListener()&#x3D;&#x3D;它是一种方法</p>
<p><code>eventTarget.addEventListenner(type,listener[,useCapture])</code></p>
<ul>
<li><p>&#x3D;&#x3D;type&#x3D;&#x3D;：事件类型&#x3D;&#x3D;字符串&#x3D;&#x3D;，比如 click、mouseover，注意这里没有on哦</p>
</li>
<li><p>&#x3D;&#x3D;listener&#x3D;&#x3D;：事件处理函数，事件发生时，会调用该监听函数</p>
</li>
<li><p>&#x3D;&#x3D;useCapture&#x3D;&#x3D;：可选参数，是一个布尔值，默认为 false </p>
<pre><code class="javascript">btn.addEventListener(&#39;click&#39;,function()&#123;
    alert(&#39;hi~&#39;)
&#125;)
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-6-2-删除事件（解绑事件）"><a href="#3-6-2-删除事件（解绑事件）" class="headerlink" title="3.6.2 删除事件（解绑事件）"></a>3.6.2 删除事件（解绑事件）</h4><h5 id="（1）传统方式删除事件"><a href="#（1）传统方式删除事件" class="headerlink" title="（1）传统方式删除事件"></a>（1）传统方式删除事件</h5><ul>
<li><p>eventTarget.onclick &#x3D; null;</p>
<pre><code class="javascript">let div = document.querySelector(&#39;div&#39;);
div.onclick = function() &#123;
    alert(&#39;hi~&#39;);
    // 删除事件
    div.onclick = null;
&#125;
</code></pre>
</li>
</ul>
<h5 id="（2）方法监听注册方式删除事件"><a href="#（2）方法监听注册方式删除事件" class="headerlink" title="（2）方法监听注册方式删除事件"></a>（2）方法监听注册方式删除事件</h5><ul>
<li><p>eventTarget.removeEventListener(type,listener[,useCapture]);</p>
<pre><code class="javascript">btn.addEventListener(&#39;click&#39;,fn);// 里面的 fn 不需要调用 所以不加小括号
function fn() &#123;
    alert(&#39;hi~&#39;);
    // 删除事件
    btn.removeEventListener(&#39;click&#39;,fn);
&#125;
</code></pre>
</li>
</ul>
<h4 id="3-6-3-DOM事件流"><a href="#3-6-3-DOM事件流" class="headerlink" title="3.6.3 DOM事件流"></a>3.6.3 DOM事件流</h4><ul>
<li><p>&#x3D;&#x3D;事件流&#x3D;&#x3D;描述的是&#x3D;&#x3D;从页面中接收事件的顺序&#x3D;&#x3D;</p>
</li>
<li><p>事件发生时会在元素节点中按照特定的顺序传播，这个传播过程即&#x3D;&#x3D;DOM事件流&#x3D;&#x3D;</p>
</li>
<li><p>DOM事件流分为三个阶段：</p>
<ul>
<li>捕获阶段</li>
<li>当前目标阶段</li>
<li>&#x3D;&#x3D;冒泡阶段&#x3D;&#x3D;<ul>
<li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave<br> <img src="https://gitee.com/colohh/image_bed/raw/master/img/DOM%E4%BA%8B%E4%BB%B6%E6%B5%81.png"></li>
</ul>
</li>
</ul>
</li>
<li><p>代码验证</p>
<ul>
<li><p>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</p>
</li>
<li><p>onclick 和 attachEvent（ie） 只能得到冒泡阶段。</p>
</li>
<li><p>捕获阶段</p>
<ul>
<li><p>如果addEventListener &#x3D;&#x3D;第三个参数是 true&#x3D;&#x3D; 那么则处于&#x3D;&#x3D;捕获阶段&#x3D;&#x3D;</p>
</li>
<li><p>document -&gt; html -&gt; body -&gt; father -&gt; son</p>
<pre><code class="javascript">// 先输出 father 再输出 son
let son = document.querySelector(&#39;.son&#39;);
son.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;son&#39;);
&#125;, true);
let father = document.querySelector(&#39;.father&#39;);
father.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;father&#39;);
&#125;, true);
</code></pre>
</li>
</ul>
</li>
<li><p>冒泡阶段 </p>
<ul>
<li><p>如果addEventListener &#x3D;&#x3D;第三个参数是 false 或者 省略&#x3D;&#x3D; 那么则处于&#x3D;&#x3D;冒泡阶段&#x3D;&#x3D;</p>
</li>
<li><p>son -&gt; father -&gt;body -&gt; html -&gt; document</p>
<pre><code class="javascript">// 先输出 son 再输出 father 最后是 document
let son = document.querySelector(&#39;.son&#39;);
son.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;son&#39;);
&#125;, false);
let father = document.querySelector(&#39;.father&#39;);
father.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;father&#39;);
&#125;, false);
document.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;document&#39;);
&#125;)
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-6-4-事件对象"><a href="#3-6-4-事件对象" class="headerlink" title="3.6.4 事件对象"></a>3.6.4 事件对象</h4><p><code>div.onclick = function(event) &#123;&#125;</code></p>
<ul>
<li><p>event 就是一个事件对象 写到我们侦听函数的小括号里面 当形参来看</p>
</li>
<li><p>&#x3D;&#x3D;事件对象只有有了事件才会存在&#x3D;&#x3D;，它是系统给我们自动创建的，不需要我们传递参数</p>
</li>
<li><p>&#x3D;&#x3D;事件对象&#x3D;&#x3D;是跟&#x3D;&#x3D;事件相关的一系列相关数据的集合（属性和方法）&#x3D;&#x3D;：比如鼠标点击里面就包含了鼠标的相关信息，鼠标坐标等；如果是键盘事件里面就包含的键盘事件的信息，比如判断用户按下了那个键</p>
</li>
<li><p>事件对象&#x3D;&#x3D;可以自己命名&#x3D;&#x3D; 比如 event 、 evt、 e</p>
</li>
<li><p>事件对象的常见属性和方法：</p>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B8%B8%E8%A7%81%E5%B1%9E%E6%80%A7%E5%92%8C%E6%96%B9%E6%B3%95.png"></p>
</li>
</ul>
<h4 id="3-6-5-阻止事件冒泡"><a href="#3-6-5-阻止事件冒泡" class="headerlink" title="3.6.5 阻止事件冒泡"></a>3.6.5 阻止事件冒泡</h4><blockquote>
<p>事件对象阻止默认行为</p>
<p>让链接不跳转或让提交按钮不提交</p>
<pre><code class="html">&lt;a href=&quot;http://www.baidu.com&quot;&gt;百度&lt;/a&gt;
&lt;script&gt;
    let a = document.querySelector(&#39;a&#39;);
    a.addEventListener(&#39;click&#39;,function(e)&#123;
        e.preventDefault;// 阻止链接跳转
    &#125;)
&lt;/script&gt;
</code></pre>
</blockquote>
<h5 id="阻止事件冒泡的方式"><a href="#阻止事件冒泡的方式" class="headerlink" title="阻止事件冒泡的方式"></a>阻止事件冒泡的方式</h5><ul>
<li><p>利用事件对象里面的 stopPropagation() 方法</p>
<p><code>e.stopPropagation()</code></p>
<pre><code class="javascript">// 先输出 son 再输出 father 最后是 document
let son = document.querySelector(&#39;.son&#39;);
son.addEventListener(&#39;click&#39;, function(e) &#123;
    alert(&#39;son&#39;);
    e.stopPropagation();// 阻止冒泡 后面的 father 和 document 都不会再响应了
&#125;, false);
let father = document.querySelector(&#39;.father&#39;);
father.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;father&#39;);
&#125;, false);
document.addEventListener(&#39;click&#39;, function() &#123;
    alert(&#39;document&#39;);
&#125;)
</code></pre>
</li>
</ul>
<h4 id="3-6-6-事件委托（代理、委派）"><a href="#3-6-6-事件委托（代理、委派）" class="headerlink" title="3.6.6 事件委托（代理、委派）"></a>3.6.6 事件委托（代理、委派）</h4><h5 id="（1）事件委托的原理"><a href="#（1）事件委托的原理" class="headerlink" title="（1）事件委托的原理"></a>（1）事件委托的原理</h5><p>不是给每个子结点单独设置事件监听器，而是将事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子结点。</p>
<h5 id="（2）事件委托的作用"><a href="#（2）事件委托的作用" class="headerlink" title="（2）事件委托的作用"></a>（2）事件委托的作用</h5><p>只操作了一次DOM，提高了程序的性能。</p>
<h5 id="（3）代码实现"><a href="#（3）代码实现" class="headerlink" title="（3）代码实现"></a>（3）代码实现</h5><blockquote>
<p>当我们点击 li 的时候，因为事件冒泡 所以也会 click 到父节点 ul ，从而触发 alert 事件，而不用给每个 li 单独绑定事件</p>
</blockquote>
<pre><code class="html">&lt;ul&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    //获取父节点
    let ul = document.querySelector(&#39;ul&#39;);
    //给父节点绑定事件
    ul.addEventListener(&#39;click&#39;,function() &#123;
        alert(&#39;hello&#39;)
    &#125;)
&lt;/script&gt;
</code></pre>
<blockquote>
<p>点击 li 改变 li 的背景颜色：</p>
</blockquote>
<pre><code class="html">&lt;ul&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
    &lt;li&gt;hello&lt;/li&gt;
&lt;/ul&gt;
&lt;script&gt;
    //获取父节点
    let ul = document.querySelector(&#39;ul&#39;);
    //给父节点绑定事件
    ul.addEventListener(&#39;click&#39;,function(e) &#123;
        // e.target 这个可以得到我们点击的对象
        e.target.style.backgroundColor = &#39;pink&#39;;
    &#125;)
&lt;/script&gt;
</code></pre>
<h4 id="3-6-7-常用的鼠标事件"><a href="#3-6-7-常用的鼠标事件" class="headerlink" title="3.6.7 常用的鼠标事件"></a>3.6.7 常用的鼠标事件</h4><h5 id="（1）鼠标事件"><a href="#（1）鼠标事件" class="headerlink" title="（1）鼠标事件"></a>（1）鼠标事件</h5><h6 id="1-常用的鼠标事件"><a href="#1-常用的鼠标事件" class="headerlink" title="1. 常用的鼠标事件"></a>1. 常用的鼠标事件</h6><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E5%B8%B8%E8%A7%81%E7%9A%84%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6.png"></p>
<ul>
<li>&#x3D;&#x3D;mouseenter 和 mouseover（mouseleave 和 mouseout） 的区别&#x3D;&#x3D;<ul>
<li>mouseenter &#x2F; mouseleave 鼠标事件<ul>
<li>mouseenter &#x2F;mouseleave 只会经过自身盒子触发（&#x3D;&#x3D;mouseenter &#x2F; mouseleave 不会冒泡&#x3D;&#x3D;）</li>
</ul>
</li>
<li>mouseover &#x2F; mouseout 鼠标事件<ul>
<li>mouseover &#x2F; mouseout 鼠标经过自身盒子会触发，经过子盒子还会触发。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h6 id="2-禁止鼠标右键菜单-了解"><a href="#2-禁止鼠标右键菜单-了解" class="headerlink" title="2. 禁止鼠标右键菜单(了解)"></a>2. 禁止鼠标右键菜单(了解)</h6><blockquote>
<p>&#x3D;&#x3D;contextmenu&#x3D;&#x3D; 主要控制应该何时显示上下文菜单，主要用于程序员&#x3D;&#x3D;取消默认的上下文菜单&#x3D;&#x3D;(禁用右键菜单)</p>
</blockquote>
<pre><code class="javascript">document.addEventListener(&#39;contextmenu&#39;,function(e) &#123;
    e.preventDefault();
&#125;)
</code></pre>
<h6 id="3-禁止选中文字-了解"><a href="#3-禁止选中文字-了解" class="headerlink" title="3. 禁止选中文字(了解)"></a>3. 禁止选中文字(了解)</h6><pre><code class="javascript">document.addEventListener(&#39;selectstart&#39;,function(e) &#123;
    e.preventDefault();
&#125;)
</code></pre>
<h5 id="（2）鼠标事件对象"><a href="#（2）鼠标事件对象" class="headerlink" title="（2）鼠标事件对象"></a>（2）鼠标事件对象</h5><blockquote>
<p>&#x3D;&#x3D;event&#x3D;&#x3D; 对象代表事件的状态，跟事件相关的一系列信息的集合。现阶段我们主要用鼠标事件对象 &#x3D;&#x3D;MouseEvent&#x3D;&#x3D; 和键盘事件对象 &#x3D;&#x3D;KeyboardEvent&#x3D;&#x3D;。</p>
</blockquote>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E9%BC%A0%E6%A0%87%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1.png"></p>
<ul>
<li><p>案例 - 跟随鼠标的天使</p>
<pre><code class="html">&lt;head&gt;
&lt;style&gt;
        img &#123;
            position: absolute;
            top: 2px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    &lt;img src=&quot;images/angel.gif&quot; alt=&quot;&quot;&gt;
    &lt;script&gt;
        var pic = document.querySelector(&#39;img&#39;);
        document.addEventListener(&#39;mousemove&#39;, function(e) &#123;
            // 1. mousemove只要我们鼠标移动1px 就会触发这个事件
            // console.log(1);
            // 2.核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片
            var x = e.pageX;
            var y = e.pageY;
            console.log(&#39;x坐标是&#39; + x, &#39;y坐标是&#39; + y);
            //3 . 千万不要忘记给left 和top 添加px 单位
            pic.style.left = x - 50 + &#39;px&#39;;
            pic.style.top = y - 40 + &#39;px&#39;;
        &#125;);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>
<h4 id="3-6-8-常用的键盘事件"><a href="#3-6-8-常用的键盘事件" class="headerlink" title="3.6.8 常用的键盘事件"></a>3.6.8 常用的键盘事件</h4><h5 id="（1）常用键盘事件"><a href="#（1）常用键盘事件" class="headerlink" title="（1）常用键盘事件"></a>（1）常用键盘事件</h5><blockquote>
<p>三个事件同时存在时的顺序： keydown – keypress – keyup</p>
</blockquote>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E5%B8%B8%E7%94%A8%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6.png"></p>
<h5 id="（2）键盘事件对象"><a href="#（2）键盘事件对象" class="headerlink" title="（2）键盘事件对象"></a>（2）键盘事件对象</h5><blockquote>
<p>键盘事件对象（keyboardEvent）中的 &#x3D;&#x3D;keyCode&#x3D;&#x3D; 属性&#x3D;&#x3D;可以得到相应键的 ASCII 码值&#x3D;&#x3D;。</p>
</blockquote>
<ul>
<li><p>利用 keyCode 判断用户按了哪个键</p>
<ul>
<li><p>keyup 和 keydown 事件不区分字母大小写：按下 a 和 A 得到的都是65</p>
<pre><code class="javascript">document.addEventListener(&#39;keyup&#39;,function(e)&#123;
    console.log(e.keyCode);
&#125;)
</code></pre>
</li>
<li><p>keypress 事件区分字母大小写：按下 A 得到65；按 a 得到97</p>
</li>
</ul>
</li>
</ul>
<h2 id="4-BOM"><a href="#4-BOM" class="headerlink" title="4. BOM"></a>4. BOM</h2><h3 id="4-1-BOM-概述"><a href="#4-1-BOM-概述" class="headerlink" title="4.1 BOM 概述"></a>4.1 BOM 概述</h3><h4 id="4-1-1-BOM-简介"><a href="#4-1-1-BOM-简介" class="headerlink" title="4.1.1 BOM 简介"></a>4.1.1 BOM 简介</h4><ul>
<li>BOM（&#x3D;&#x3D;浏览器对象模型&#x3D;&#x3D;），它提供了独立于内容而与&#x3D;&#x3D;浏览器窗口进行交互的对象&#x3D;&#x3D;，其&#x3D;&#x3D;核心对象是 window&#x3D;&#x3D;。</li>
<li>BOM 学习的是浏览器窗口交互的一些对象</li>
<li>BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差</li>
<li>BOM 由一系列相关的对象组成，并且每个对象都提供了很多方法和属性。</li>
</ul>
<h4 id="4-1-2-BOM-构成"><a href="#4-1-2-BOM-构成" class="headerlink" title="4.1.2 BOM 构成"></a>4.1.2 BOM 构成</h4><p>BOM 比 DOM 更大，它包含 DOM</p>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/BOM%E7%9A%84%E6%9E%84%E6%88%90.png"></p>
<h3 id="4-2-window-对象的常见事件"><a href="#4-2-window-对象的常见事件" class="headerlink" title="4.2 window 对象的常见事件"></a>4.2 window 对象的常见事件</h3><ul>
<li>&#x3D;&#x3D;window 对象是浏览器的顶级对象&#x3D;&#x3D;，它具有双重角色<ul>
<li>它是 JS 访问浏览器窗口的一个接口。</li>
<li>他是一个全局对象，定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法</li>
</ul>
</li>
</ul>
<h4 id="4-2-1-窗口加载事件"><a href="#4-2-1-窗口加载事件" class="headerlink" title="4.2.1 窗口加载事件"></a>4.2.1 窗口加载事件</h4><blockquote>
<p>当文档内容完全加载完成会触发该事件（包括图像、脚本文件、CSS文件等）</p>
<p>以前 js 部分只能放到 css布局的下面，&#x3D;&#x3D;用这个方法 js 部分就可以放在文件的任意位置&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>window.onload </p>
</li>
<li><p>但这种传统的注册事件方式只能写一次，若写了多个，以最后一个为准</p>
<pre><code class="javascript">window.onload = function()&#123;
    ...
&#125;
</code></pre>
</li>
<li><p>&#x3D;&#x3D;window.addEventListener(‘load’, function() {})&#x3D;&#x3D;</p>
<ul>
<li><p>可以写任意个事件，没有限制</p>
<pre><code class="javascript">window.addEventListener(&#39;load&#39;, function() &#123;
    ...
&#125;)
</code></pre>
</li>
</ul>
</li>
<li><p>document.addEventlistener(‘DOMContentLoaded’,function() {})</p>
<ul>
<li>仅当 DOM 加载完成（不包含样式表、图片、flash等）时，即触发事件。</li>
<li>好处：页面图片过多时，用户访问到onload触发可能需要较长时间，交互效果就不能实现，影响用户体验。此时用 DOMContentLoaded 即可解决。</li>
</ul>
</li>
</ul>
<h4 id="4-2-2-调整窗口大小事件"><a href="#4-2-2-调整窗口大小事件" class="headerlink" title="4.2.2 调整窗口大小事件"></a>4.2.2 调整窗口大小事件</h4><blockquote>
<p>只要窗口大小发生像素变化，就会触发这个事件</p>
</blockquote>
<ul>
<li><p>resize</p>
<ul>
<li><p>使用方式</p>
<pre><code class="javascript">window.onresize = function() &#123;&#125;
window.addEventListener(&#39;resize&#39;,function() &#123;&#125;)
</code></pre>
</li>
<li><p>常用场景</p>
<blockquote>
<p>响应式布局：当我们把浏览器窗口缩小到一定大小时，隐藏某些节点</p>
</blockquote>
<pre><code class="javascript">let div = document.querySelector(&#39;div&#39;);
windows.addEventLisener(&#39;resize&#39;,function() &#123;
    // window.innerWidth 为浏览器窗口宽度
    if (window.innerWidth &lt;= 800) &#123;
        div.style.display = &#39;none&#39;;
    &#125;
&#125;)
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="4-3-定时器"><a href="#4-3-定时器" class="headerlink" title="4.3 定时器"></a>4.3 定时器</h3><h4 id="4-3-1-setTimeout-定时器"><a href="#4-3-1-setTimeout-定时器" class="headerlink" title="4.3.1 setTimeout() 定时器"></a>4.3.1 setTimeout() 定时器</h4><blockquote>
<p>setTimeout() 这个调用函数我们也称为&#x3D;&#x3D;回调函数 callback&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>语法规范（window可以省略）</p>
<ul>
<li><p>&#x3D;&#x3D;定时器到期后调用函数&#x3D;&#x3D;</p>
</li>
<li><p>延时时间单位是毫秒，可以省略</p>
</li>
<li><p>这个调用函数可以直接写函数，还可以写函数名</p>
<pre><code class="javascript">window.setTimeout(调用函数，[延迟的毫秒数]);
</code></pre>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;停止定时器 clearTimeout()&#x3D;&#x3D;</p>
<ul>
<li><p>语法规范</p>
<pre><code class="javascript">window.clearTimeout(timeoutID)
</code></pre>
</li>
<li><p>实际运用</p>
<pre><code class="html">&lt;button&gt;点击停止计时器&lt;/button&gt;
&lt;script&gt;
    let btn = document.querySelector(&#39;button&#39;);
    let timer = setTimeout(function() &#123;
        console.log(&#39;boom!&#39;)
    &#125;,5000);
    btn.addEventListener(&#39;click&#39;,function() &#123;
        clearTimeout(timer);// 停止计时器
    &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-2-setInterval-定时器"><a href="#4-3-2-setInterval-定时器" class="headerlink" title="4.3.2 setInterval() 定时器"></a>4.3.2 setInterval() 定时器</h4><ul>
<li><p>语法规范（window可以省略）</p>
<ul>
<li><p>&#x3D;&#x3D;反复调用&#x3D;&#x3D;这个函数：&#x3D;&#x3D;每隔这个时间，就去调用一次这个函数&#x3D;&#x3D;</p>
</li>
<li><p>间隔的毫秒数默认是 0 </p>
</li>
<li><p>第一次执行时也有间隔毫秒数，因此刷新页面会有空白</p>
<ul>
<li>解决方式：可以先调用一次这个函数（setInterval()之前），防止刷新后空白</li>
</ul>
</li>
<li><p>这个调用函数可以直接写函数，还可以写函数名</p>
<pre><code class="javascript">window.setInterval(回调函数，[间隔的毫秒数]);
</code></pre>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;停止定时器 clearInterval()&#x3D;&#x3D;</p>
<ul>
<li><p>语法规范</p>
<pre><code class="javascript">window.clearInterval(timeoutID)
</code></pre>
</li>
<li><p>实际运用</p>
<pre><code class="html">&lt;button class=&quot;begin&quot;&gt;点击开启计时器&lt;/button&gt;
&lt;button class=&quot;stop&quot;&gt;点击停止计时器&lt;/button&gt;
&lt;script&gt;
    let begin = document.querySelector(&#39;.begin&#39;);
    let stop = document.querySelector(&#39;.stop&#39;);
    let timer = null;// 全局变量 null是一个空对象
    begin.addEventListener(&#39;click&#39;,function() &#123;
        timer = setInterval(function() &#123;
            console.log(&#39;boom&#39;)
        &#125;,1000);
    &#125;)
    stop.addEventListener(&#39;click&#39;,function() &#123;
        clearInterval(timer);// 停止计时器
    &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-3-3-this指向问题"><a href="#4-3-3-this指向问题" class="headerlink" title="4.3.3 this指向问题"></a>4.3.3 this指向问题</h4><blockquote>
<p>一般情况下this的最终指向的是那个调用它的对象</p>
</blockquote>
<ul>
<li><p>全局作用域或者普通函数中this指向全局对象window（ 注意定时器里面的this指向window）</p>
<pre><code class="javascript">console.log(this);

function fn() &#123;
    console.log(this);
&#125;

window.setTimeout(function() &#123;
    console.log(this);

&#125;, 1000);
</code></pre>
</li>
<li><p>方法调用中谁调用this指向谁</p>
<pre><code class="javascript">let o = &#123;
    sayHi: function() &#123;
        console.log(this); // this指向的是 o 这个对象
    &#125;
&#125;
o.sayHi(); 
</code></pre>
</li>
<li><p>构造函数中this指向构造函数的实例</p>
<pre><code class="javascript">function Fun() &#123;
    console.log(this); // this 指向的是fun 实例对象
&#125;
var fun = new Fun();
</code></pre>
</li>
</ul>
<h3 id="4-4-JS-执行机制"><a href="#4-4-JS-执行机制" class="headerlink" title="4.4 JS 执行机制"></a>4.4 JS 执行机制</h3><blockquote>
<p>&#x3D;&#x3D;JS 是单线程&#x3D;&#x3D;同一个时间只做一件事</p>
</blockquote>
<h4 id="4-4-1-同步和异步"><a href="#4-4-1-同步和异步" class="headerlink" title="4.4.1 同步和异步"></a>4.4.1 同步和异步</h4><blockquote>
<p>为了解决这个问题，利用多核 CPU 的能力，H5 提出 Web Worker 标准，允许 JS脚本创建多个线程。于是，JS中出现了&#x3D;&#x3D;同步&#x3D;&#x3D;和&#x3D;&#x3D;异步&#x3D;&#x3D;。</p>
</blockquote>
<h5 id="（1）同步"><a href="#（1）同步" class="headerlink" title="（1）同步"></a>（1）同步</h5><ul>
<li>前一个任务结束后再执行下一个任务，程序的执行顺序和任务的排列顺序是一样的。</li>
<li>同步任务都在主线程上执行，形成一个&#x3D;&#x3D;执行栈&#x3D;&#x3D;</li>
</ul>
<h5 id="（2）异步"><a href="#（2）异步" class="headerlink" title="（2）异步"></a>（2）异步</h5><ul>
<li>在做这件事的同时，还可以处理其他事情。</li>
<li>JS 的&#x3D;&#x3D;异步&#x3D;&#x3D;是通过&#x3D;&#x3D;回调函数&#x3D;&#x3D;实现的。异步任务相关&#x3D;&#x3D;回调函数&#x3D;&#x3D;添加到&#x3D;&#x3D;任务队列&#x3D;&#x3D;（消息队列）中</li>
<li>一般而言，异步任务有以下三种类型：<ul>
<li>普通事件：如 click、resize 等</li>
<li>资源加载：如 load、error 等</li>
<li>定时器：如 setInterval、setTimeout 等</li>
</ul>
</li>
</ul>
<h4 id="4-4-2-执行机制"><a href="#4-4-2-执行机制" class="headerlink" title="4.4.2 执行机制"></a>4.4.2 执行机制</h4><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png"></p>
<ul>
<li>先执行&#x3D;&#x3D;执行栈中的同步任务&#x3D;&#x3D;。</li>
<li>异步任务（回调函数）放入任务队列中。</li>
<li>一旦&#x3D;&#x3D;执行栈中的所有同步任务执行完毕&#x3D;&#x3D;，系统就会按次序读取&#x3D;&#x3D;任务队列&#x3D;&#x3D;中的&#x3D;&#x3D;异步任务&#x3D;&#x3D;，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</li>
</ul>
<h3 id="4-5-location-对象"><a href="#4-5-location-对象" class="headerlink" title="4.5 location 对象"></a>4.5 location 对象</h3><blockquote>
<p>window 对象给我们提供了一个 &#x3D;&#x3D;location 属性&#x3D;&#x3D;用于&#x3D;&#x3D;获取或设置窗体的 URL&#x3D;&#x3D;（网址），并且可以用来&#x3D;&#x3D;解析 URL&#x3D;&#x3D; 。因为这个属性返回的是一个对象，所以我们将这个属性也称为 &#x3D;&#x3D;location 对象&#x3D;&#x3D;</p>
</blockquote>
<h4 id="4-5-1-location-对象的属性"><a href="#4-5-1-location-对象的属性" class="headerlink" title="4.5.1 location 对象的属性"></a>4.5.1 location 对象的属性</h4><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/location%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7.png"></p>
<h5 id="（1）location-href"><a href="#（1）location-href" class="headerlink" title="（1）location.href"></a>（1）location.href</h5><ul>
<li><p>可以获取网址或实现跳转</p>
<pre><code class="html">&lt;button&gt;点击&lt;/button&gt;
&lt;script&gt;
        let btn = document.querySelector(&#39;button&#39;);
        let div = document.querySelector(&#39;div&#39;);
        btn.addEventListener(&#39;click&#39;, function() &#123;
            console.log(location.href);// 获取网址
            location.href = &#39;http://www.itcast.cn&#39;; // 实现跳转
        &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="（2）location-search"><a href="#（2）location-search" class="headerlink" title="（2）location.search"></a>（2）location.search</h5><ul>
<li><p>可以返回参数 (详见 Web APIs-第三天-10-获取URL参数)</p>
<ul>
<li><p>登陆页面 login.html</p>
<pre><code class="html">&lt;body&gt;
    登陆页面
    &lt;!-- form实现跳转  --&gt;
    &lt;form action=&quot;index.html&quot; method=&quot;
    get&quot;&gt; 
        用户名：
        &lt;input type=&quot;text&quot; name=&quot;uname&quot;&gt;
        &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt;
    &lt;/form&gt;
&lt;/body&gt;
</code></pre>
</li>
<li><p>主页 index.html</p>
<pre><code class="html">&lt;body&gt;
    首页
    &lt;div&gt;
        &lt;i&gt;andy&lt;/i&gt; 欢迎光临
    &lt;/div&gt;
    &lt;script&gt;
        let i = document.querySelector(&#39;i&#39;);
        // 通过 location.search 把参数 uname 拿过来
        console.log(location.search);// ?uname=andy
        // 1.先去掉？ substr(&#39;起始的位置&#39;,截取几个字符)
        let params = location.search.substr(1);
        // 2.利用 = 把字符串分割为数组 split(&#39;=&#39;);
        let arr = params.split(&#39;=&#39;);
        // 3.把数据写入div中
        i.innerHTML = arr[1];
        // console.log(location.href)
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="4-5-2-location-对象的方法"><a href="#4-5-2-location-对象的方法" class="headerlink" title="4.5.2 location 对象的方法"></a>4.5.2 location 对象的方法</h4><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/location%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95.png"></p>
<h5 id="（1）location-assign"><a href="#（1）location-assign" class="headerlink" title="（1）location.assign()"></a>（1）location.assign()</h5><ul>
<li><p>跳转页面</p>
<ul>
<li>&#x3D;&#x3D;location.assign() 是记录浏览历史的，所以可以实现后退功能&#x3D;&#x3D;</li>
</ul>
<pre><code class="html">&lt;button&gt;按钮&lt;/button&gt;
&lt;script&gt;
    let btn = document.querySelector(&#39;button&#39;);
    btn.addEventListener(&#39;click&#39;,function() &#123;
        location.assign(&#39;https://www.bilibili.com&#39;);
    &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h5 id="（2）location-replace"><a href="#（2）location-replace" class="headerlink" title="（2）location.replace()"></a>（2）location.replace()</h5><ul>
<li>跳转页面，用法同 assign</li>
<li>location.replace() 不记录浏览历史，所以&#x3D;&#x3D;不能后退&#x3D;&#x3D;</li>
</ul>
<h5 id="（3）location-reload"><a href="#（3）location-reload" class="headerlink" title="（3）location.reload()"></a>（3）location.reload()</h5><ul>
<li><p>刷新页面</p>
<pre><code class="html">&lt;button&gt;按钮&lt;/button&gt;
&lt;script&gt;
    let btn = document.querySelector(&#39;button&#39;);
    btn.addEventListener(&#39;click&#39;,function() &#123;
        location.reload();
        location.reload(ture);// 强制刷新
    &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h3 id="4-6-navigator-对象"><a href="#4-6-navigator-对象" class="headerlink" title="4.6 navigator 对象"></a>4.6 navigator 对象</h3><blockquote>
<p>navigator 对象包含有关浏览器的信息，他有很多属性，&#x3D;&#x3D;我们最常用的是 userAgent&#x3D;&#x3D;，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
</blockquote>
<ul>
<li><p>下面一段代码可以判断用户从哪个终端打开页面，实现跳转</p>
<pre><code class="javascript">
if((navigator.userAgent.match(/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i))) &#123;
    window.location.href = &quot;../H5/index.html&quot;; //手机
&#125;
</code></pre>
</li>
</ul>
<h3 id="4-7-history-对象"><a href="#4-7-history-对象" class="headerlink" title="4.7 history 对象"></a>4.7 history 对象</h3><blockquote>
<p>window 对象给我们提供了一个 &#x3D;&#x3D;history 对象&#x3D;&#x3D;，与&#x3D;&#x3D;浏览器历史记录进行交互&#x3D;&#x3D;。该对象包含用户（在浏览器窗口中）访问过的 URL。</p>
</blockquote>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/history%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95.png"></p>
<p>代码示例：</p>
<pre><code class="html">&lt;body&gt;
    &lt;a href=&quot;list.html&quot;&gt;点击我去往列表页&lt;/a&gt;
    &lt;button&gt;前进&lt;/button&gt;
    &lt;script&gt;
        let btn = document.querySelector(&#39;button&#39;);
        btn.addEventListener(&#39;click&#39;,function() &#123;
            // history.forward()
            // 前进
            history.go(1)
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>

  </div>
  <div id="gitalk-container"></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging">
    
    <a href="/2022/11/11/JavaScript%E9%AB%98%E7%BA%A7/">
        <div class="post-paging-last">
            <span>上一篇</span>
            <p>JavaScript高级</p>
        </div>
    </a>
    

    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2022 By sheep. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/79e/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?94ea92e08139a609b3e9a9fd82080c82";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"f9b10e7298e1a0d041ea","clientSecret":"ed9c807b5965710c6636de27d7972668257d348c","repo":"myblogtalk","owner":"sheep1005","admin":"sheep1005"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('true')){
            gitalk.render('gitalk-container')
        }
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>

