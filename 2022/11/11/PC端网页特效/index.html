<!DOCTYPE html>
<html>
	<head>
		
<title>PC端网页特效-hi</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="前端,学习笔记,JavaScript,">
<meta name="description" content="可以实现花里胡哨的交互哦">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.highlightAll();</script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>sheep</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 66%;
        height: 100%;
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815);
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					right: "0"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					right: "-100%"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-color"
    style="background: url('')" 
>
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
            
            <li><a href="/tags/前端">前端</a></li>
            
            <li><a href="/tags/学习笔记">学习笔记</a></li>
            
            <li><a href="/tags/JavaScript">JavaScript</a></li>
            
            
        </ul>
        
        <h1>PC端网页特效</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                        <g>
                            <path fill="#12183A"
                                d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                            </path>
                        </g>
                    </svg>
                
                <span class="post-header-info-author-text"> <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">Sheep</a></span>
                <div class="post-header-info-author-categories">
                    
                         <a href="../../categories/JavaScript/" target="_blank" >JavaScript</a>
                    
                </div>
                <p>2022-11-11 20:33:36</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h1 id="1-三大系列"><a href="#1-三大系列" class="headerlink" title="1. 三大系列"></a>1. 三大系列</h1><h2 id="1-1-三大系列总结"><a href="#1-1-三大系列总结" class="headerlink" title="1.1 三大系列总结"></a>1.1 三大系列总结</h2><h3 id="1-1-1-三大系列大小对比"><a href="#1-1-1-三大系列大小对比" class="headerlink" title="1.1.1 三大系列大小对比"></a>1.1.1 三大系列大小对比</h3><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E4%B8%89%E5%A4%A7%E7%B3%BB%E5%88%97%E6%80%BB%E7%BB%93.png"></p>
<h3 id="1-1-2-三大系列的主要使用场景"><a href="#1-1-2-三大系列的主要使用场景" class="headerlink" title="1.1.2 三大系列的主要使用场景"></a>1.1.2 三大系列的主要使用场景</h3><ul>
<li>&#x3D;&#x3D;offset&#x3D;&#x3D; 系列经常用于&#x3D;&#x3D;获得元素位置&#x3D;&#x3D; &#x3D;&#x3D;offsetLeft offsetTop&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;client&#x3D;&#x3D; 经常用于&#x3D;&#x3D;获得元素大小&#x3D;&#x3D; &#x3D;&#x3D;clientWidth clientHeight&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;scroll&#x3D;&#x3D; 经常用于&#x3D;&#x3D;获得滚动距离&#x3D;&#x3D; &#x3D;&#x3D;scrollTop scrollLeft&#x3D;&#x3D;</li>
<li>注意：&#x3D;&#x3D;页面&#x3D;&#x3D;的滚动距离通过 &#x3D;&#x3D;window.pageYOffset&#x3D;&#x3D; 获得</li>
</ul>
<h2 id="1-2-元素偏移量-offset-系列"><a href="#1-2-元素偏移量-offset-系列" class="headerlink" title="1.2 元素偏移量 offset 系列"></a>1.2 元素偏移量 offset 系列</h2><h3 id="1-2-1-offset-概述"><a href="#1-2-1-offset-概述" class="headerlink" title="1.2.1 offset 概述"></a>1.2.1 offset 概述</h3><p>&#x3D;&#x3D;offset&#x3D;&#x3D; 翻译过来就是偏移量，我们使用offset系列相关属性可以&#x3D;&#x3D;动态的&#x3D;&#x3D;得到该元素的&#x3D;&#x3D;位置（偏移）、大小等&#x3D;&#x3D;。</p>
<ul>
<li>获得元素距离&#x3D;&#x3D;带有定位的&#x3D;&#x3D;父元素的位置</li>
<li>获得元素自身的大小（高度宽度）</li>
<li>注意：&#x3D;&#x3D;返回的数值不带单位&#x3D;&#x3D;</li>
</ul>
<h3 id="1-2-2-offset-系列常用属性"><a href="#1-2-2-offset-系列常用属性" class="headerlink" title="1.2.2 offset 系列常用属性"></a>1.2.2 offset 系列常用属性</h3><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/offset%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7.png"></p>
<ul>
<li>offsetWidth 可以得到元素的大小（包括边框），但不包含超出内容的长度；</li>
</ul>
<h3 id="1-2-3-offset-与-style-区别"><a href="#1-2-3-offset-与-style-区别" class="headerlink" title="1.2.3 offset 与 style 区别"></a>1.2.3 offset 与 style 区别</h3><table>
<thead>
<tr>
<th align="left">offset</th>
<th align="left">style</th>
</tr>
</thead>
<tbody><tr>
<td align="left">offset 可以得到任意样式表中的样式值</td>
<td align="left">style 只能得到行内样式表中的样式值</td>
</tr>
<tr>
<td align="left">offset 系列获得的数值是没有单位的</td>
<td align="left">style.width 获得的是带有单位的字符串</td>
</tr>
<tr>
<td align="left">offsetWidth 包含 padding+border+width</td>
<td align="left">style.width 获得不包含 padding 和 border的值</td>
</tr>
<tr>
<td align="left">offsetWidth 等属性是&#x3D;&#x3D;只读属性&#x3D;&#x3D;，&#x3D;&#x3D;只能获取不能赋值&#x3D;&#x3D;</td>
<td align="left">style.width是&#x3D;&#x3D;可读写属性&#x3D;&#x3D;，&#x3D;&#x3D;可以获取也可以赋值&#x3D;&#x3D;</td>
</tr>
<tr>
<td align="left">&#x3D;&#x3D;我们想要获取大量元素大小位置，用 offset&#x3D;&#x3D;</td>
<td align="left">&#x3D;&#x3D;我们想要给元素更改值，用 style&#x3D;&#x3D;</td>
</tr>
</tbody></table>
<ul>
<li><p>案例 - 计算鼠标在盒子内的坐标</p>
<pre><code class="html">&lt;head&gt;
    &lt;style&gt;
        div &#123;
            width: 200px;
            height: 200px;
            background-color: pink;
            margin: 100px;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        let div = document.querySelector(&#39;div&#39;);
        div.addEventListener(&#39;mousemove&#39;,function(e) &#123;
            // 鼠标在盒子内的坐标等于 鼠标相对文档页面的坐标 减去 box 相对父元素的坐标（此处父元素没有定位，则相对body）
            let x = e.pageX - this.offsetLeft;
            let y = e.pageY - this.offsetTop;
            this.innerHTML = &#39;x坐标为：&#39; + x + &#39;y坐标为：&#39; + y;
        &#125;)
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>
<h2 id="1-3-元素可视区-client-系列"><a href="#1-3-元素可视区-client-系列" class="headerlink" title="1.3 元素可视区 client 系列"></a>1.3 元素可视区 client 系列</h2><h3 id="1-3-1-client-概述"><a href="#1-3-1-client-概述" class="headerlink" title="1.3.1 client 概述"></a>1.3.1 client 概述</h3><p>&#x3D;&#x3D;client&#x3D;&#x3D; 翻译过来就是客户端，我们使用 &#x3D;&#x3D;client&#x3D;&#x3D; 相关属性来&#x3D;&#x3D;获取元素可视区的相关信息&#x3D;&#x3D;。通过 client 系列的相关属性可以动态的得到该元素的&#x3D;&#x3D;边框大小、元素大小&#x3D;&#x3D;等。</p>
<h3 id="1-3-2-client-系列属性"><a href="#1-3-2-client-系列属性" class="headerlink" title="1.3.2 client 系列属性"></a>1.3.2 client 系列属性</h3><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/client%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7.png"></p>
<ul>
<li>clientWidth 和 offsetWidth 一样，也可以得到元素的大小，但 &#x3D;&#x3D;clientWidth 返回的宽度，不包含边框（border）&#x3D;&#x3D;，且&#x3D;&#x3D;不包含超出内容的长度&#x3D;&#x3D;；</li>
</ul>
<h2 id="1-4-元素滚动-scroll-系列"><a href="#1-4-元素滚动-scroll-系列" class="headerlink" title="1.4 元素滚动 scroll 系列"></a>1.4 元素滚动 scroll 系列</h2><h3 id="1-4-1-scroll-概述"><a href="#1-4-1-scroll-概述" class="headerlink" title="1.4.1 scroll 概述"></a>1.4.1 scroll 概述</h3><p>&#x3D;&#x3D;scroll&#x3D;&#x3D; 翻译过来就是滚动的，我们使用 scroll 系列的相关属性可以动态的得到&#x3D;&#x3D;该元素的大小、滚动距离等&#x3D;&#x3D;</p>
<h3 id="1-4-2-scroll-系列属性"><a href="#1-4-2-scroll-系列属性" class="headerlink" title="1.4.2 scroll 系列属性"></a>1.4.2 scroll 系列属性</h3><p><img src="https://gitee.com/colohh/image_bed/raw/master/img/scroll%E7%B3%BB%E5%88%97%E5%B1%9E%E6%80%A7.png"></p>
<ul>
<li><p>scrollTop</p>
<ul>
<li><p>得到的是被卷曲的内容长度（即 &#x3D;&#x3D;box 上沿到文字内容最上端&#x3D;&#x3D;的距离）</p>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/scrollTop.png"></p>
</li>
</ul>
</li>
<li><p>scrollWidth </p>
<ul>
<li>和 offsetWidth、clientWidth 一样，也可以得到元素的大小，但 &#x3D;&#x3D;scrollWidth 返回的宽度，不包含边框（border）&#x3D;&#x3D;，且&#x3D;&#x3D;包含超出内容的长度&#x3D;&#x3D;；</li>
</ul>
</li>
</ul>
<h3 id="1-4-3-scroll-滚动事件"><a href="#1-4-3-scroll-滚动事件" class="headerlink" title="1.4.3 scroll 滚动事件"></a>1.4.3 scroll 滚动事件</h3><ul>
<li><p>当我们滚动条发生变化时触发的事件</p>
</li>
<li><p>代码示例：</p>
<pre><code class="javascript">let div = document.querySelector(&#39;div&#39;);
div.addEventListener(&#39;scroll&#39;,function() &#123;
    console.log(div.scrollTop);// 这个值不是超出内容的长度，是会随着滚动不停变化的
&#125;)
</code></pre>
</li>
</ul>
<h2 id="1-5-案例：仿淘宝固定右侧侧边栏"><a href="#1-5-案例：仿淘宝固定右侧侧边栏" class="headerlink" title="1.5 案例：仿淘宝固定右侧侧边栏"></a>1.5 案例：仿淘宝固定右侧侧边栏</h2><blockquote>
<p>以前学过用 粘性定位 sticky 实现</p>
</blockquote>
<h3 id="1-5-1-案例要求"><a href="#1-5-1-案例要求" class="headerlink" title="1.5.1 案例要求"></a>1.5.1 案例要求</h3><ol>
<li>原先侧边栏是绝对定位</li>
<li>当页面滚动到一定位置，侧边栏改为固定定位</li>
<li>页面继续滚动，会让”返回顶部“显示出来</li>
</ol>
<h3 id="1-5-2-案例分析"><a href="#1-5-2-案例分析" class="headerlink" title="1.5.2 案例分析"></a>1.5.2 案例分析</h3><ul>
<li>需要用到页面滚动事件 scroll 因为是页面滚动，所以事件源是 document</li>
<li>滚动到某个位置，就是找出该位置页面被卷曲的上部值</li>
<li>&#x3D;&#x3D;页面被卷曲的头部&#x3D;&#x3D;：可以通过 &#x3D;&#x3D;window.pageYOffset&#x3D;&#x3D; 获得；如果被&#x3D;&#x3D;卷曲的是左部&#x3D;&#x3D; 则是 &#x3D;&#x3D;window.pageXOffset&#x3D;&#x3D;</li>
<li><strong>注意</strong>：&#x3D;&#x3D;元素&#x3D;&#x3D;被卷曲的头部可以用 &#x3D;&#x3D;element.scrollTop&#x3D;&#x3D;，而这里是&#x3D;&#x3D;页面&#x3D;&#x3D;被卷曲的头部则是 &#x3D;&#x3D;window.pageYOffset&#x3D;&#x3D;</li>
</ul>
<h3 id="1-5-3-代码实现"><a href="#1-5-3-代码实现" class="headerlink" title="1.5.3 代码实现"></a>1.5.3 代码实现</h3><pre><code class="html">&lt;head&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        .w &#123;
            width: 1200px;
            margin: 10px auto;
        &#125;
        .slider-bar &#123;
            position: absolute;
            left: 50%;
            top: 300px;
            margin-left: 600px;
            width: 45px;
            height: 130px;
            background-color: pink;
        &#125;
        span &#123;
            display: none;
            position: absolute;
            bottom: 0;
        &#125;
        .header &#123;
            height: 150px;
            background-color: purple;
        &#125;
        .banner &#123;
            height: 250px;
            background-color: skyblue;
        &#125;
        .main &#123;
            height: 1000px;
            background-color: yellowgreen;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;slider-bar&quot;&gt;&lt;!-- 侧边栏 --&gt;
        &lt;span class=&quot;goBack&quot;&gt;返回顶部&lt;/span&gt;
    &lt;/div&gt;
    &lt;div class=&quot;header w&quot;&gt;头部区域&lt;/div&gt;
    &lt;div class=&quot;banner w&quot;&gt;banner区域&lt;/div&gt;
    &lt;div class=&quot;main w&quot;&gt;主体部分&lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素
        let sliderbar = document.querySelector(&#39;.slider-bar&#39;);
        let banner = document.querySelector(&#39;.banner&#39;);
        let bannerTop = banner.offsetTop;
        // 当侧边栏固定之后应该变化的数值
        let sliderbarTop = sliderbar.offsetTop - bannerTop;
        // 获取 main 主体元素 
        let main = document.querySelector(&#39;.main&#39;);
        let goBack = document.querySelector(&#39;.goBack&#39;);
        let mainTop = main.offsetTop;
        // 2. 页面滚动事件 scroll
        document.addEventListener(&#39;scroll&#39;,function() &#123;
            // window.pageYOffset 页面被卷曲的头部
            // 3. 当我们被卷曲的头部 &gt;= banner.offsetTop，此时侧边栏改为固定定位
            if (window.pageYOffset &gt;= bannerTop) &#123;
                // 把侧边栏改为固定定位
                sliderbar.style.position = &#39;fixed&#39;;
                sliderbar.style.top = sliderbarTop + &#39;px&#39;;
            &#125; else &#123;
                // 再把侧边栏改回绝对定位
                sliderbar.style.position = &#39;absolute&#39;;
                sliderbar.style.top = &#39;300px&#39;;
            &#125;
            // 4. 当我们页面滚动到 main 模块，就显示 goBack 盒子
            if (window.pageYOffset &gt;= mainTop) &#123;
                goBack.style.display = &#39;block&#39;;
            &#125; else &#123;
                goBack.style.display = &#39;none&#39;;
            &#125;
        &#125;
        )
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
<h2 id="1-6-案例：淘宝-flexble-js-源码分析"><a href="#1-6-案例：淘宝-flexble-js-源码分析" class="headerlink" title="1.6 案例：淘宝 flexble.js 源码分析"></a>1.6 案例：淘宝 flexble.js 源码分析</h2><blockquote>
<p>针对&#x3D;&#x3D;手机端&#x3D;&#x3D; flexble.js 的源码分析</p>
</blockquote>
<h3 id="1-6-1-立即执行函数-function"><a href="#1-6-1-立即执行函数-function" class="headerlink" title="1.6.1 立即执行函数 (function() {}) ()"></a>1.6.1 立即执行函数 (function() {}) ()</h3><ul>
<li><p>立即执行函数：&#x3D;&#x3D;不需要调用，立马能够自己执行的函数&#x3D;&#x3D;</p>
</li>
<li><p>主要作用：创建一个&#x3D;&#x3D;独立的作用域&#x3D;&#x3D;，避免了命名冲突的问题</p>
</li>
<li><p>写法：</p>
<ul>
<li><p>这里 function() 后面接的 () 其实就是调用的意思了</p>
</li>
<li><p>(function() {}) ()</p>
<pre><code class="javascript">(function() &#123;
    console.log(2)
&#125;)();
// 也可以传递参数进来
(function(a,b)&#123;
    console.log(a + b);
&#125;)(2 + 3)
</code></pre>
</li>
<li><p>(function() {}())</p>
<pre><code class="javascript">(function() &#123;
    console.log(3)
&#125;());
// 也可以传递参数进来
(function(a,b) &#123;
    console.log(a + b)
&#125;(2 + 3))
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="1-6-2-load事件触发的三种情况"><a href="#1-6-2-load事件触发的三种情况" class="headerlink" title="1.6.2 load事件触发的三种情况"></a>1.6.2 load事件触发的三种情况</h3><ul>
<li><p>a 标签的超链接</p>
</li>
<li><p>F5 或者刷新按钮（强制刷新）</p>
</li>
<li><p>前进后退按钮</p>
<blockquote>
<p>火狐中有个”往返缓存“ 点击链接后后退到原来的页面，页面不会刷新，所以 load 时间也不会被触发。</p>
<blockquote>
<p>此时可以使用 pageshow 事件来触发，无论页面是否来缓存，在重新加载页面中，pageshow 会在 load 事件触发后触发；根据事件对象中的 persisted 来判断是否是缓存中的页面触发的 pageshow 事件，&#x3D;&#x3D;注意这个事件给 window 添加。&#x3D;&#x3D;</p>
</blockquote>
</blockquote>
</li>
</ul>
<h3 id="1-6-3-源码及详细解析"><a href="#1-6-3-源码及详细解析" class="headerlink" title="1.6.3 源码及详细解析"></a>1.6.3 源码及详细解析</h3><pre><code class="javascript">(function(windows,document) &#123;
    // 获取的 html 的根元素
    let docEl = document.documentElement;
    // dpr：物理像素比；pc端为1；ipone 678 为 2 
    // 若能拿到 devicePixelRatio 则dpr为 devicePixelRatio，否则看作 1
    let dpr = windows.devicePixelRatio || 1

    // adjust body font size 设置 body 字体大小
    function setBodyFontSize() &#123;
        // 判断页面是否有 body 这个元素
        // 如果有，就设置 body 的字体大小
        if (document.body) &#123;
            document.body.style.fontSize = (12 * dpr) + &#39;px&#39;
        &#125; else &#123;
            // 如果没有（比如js引入代码写在 body 之前时），则等待页面主要的 DOM 元素加载完毕后（DOMContentLoaded）再去设置 body
            document.addEventListener(&#39;DOMContentLoaded&#39;,setBodyFontSize)
        &#125;
    &#125;
    setBodyFontSize();// 一开始就调用 setBodyFontSize 函数

    // set 1rem = viewWidth / 10 设置 html 元素的文字大小
    function setRemUnit() &#123;
        // 设置 1rem 的大小为 网页端的 1/10
        let rem = docEl.clientWidth / 10
        // 设置移动端的宽度为 网页端的 1/10
        docEl.style.fontSize = rem + &#39;px&#39;
    &#125;
    setRemUnit()

    // reset rem unit on page resize 但我们页面尺寸大小发生变化的时候，要重新设置下 rem 的大小
        // resize事件 尺寸发生变化时触发
    window.addEventListener(&#39;resize&#39;,setRemUnit)
        // pageshow事件 页面重新加载时触发
    window.addEventListener(&#39;pageshow&#39;,function(e) &#123;
        // persisted 来判断是否是缓存中的页面触发的 pageshow 事件；如果为 true 则 需要重新计算rem大小，照顾 firefox 浏览器
        if (e.persisted) &#123;
            setRemUnit()
        &#125;
    &#125;)

    // detect 0.5px supports 有些移动端的浏览器不支持0.5像素的写法
    // 了解实现什么功能即可
    if (dpr &gt;= 2) &#123;
        let fakeBody = document.createElement(&#39;body&#39;)
        let testElement = document.createElement(&#39;div&#39;)
        testElement.style.border = &#39;.5px solid transparent&#39;
        fakeBody.appendChild(testElement)
        docEl.appendChild(fakeBody)
        if (testElement.offsetHeight === 1) &#123;
            docEl.classList.add(&#39;hairlines&#39;)
        &#125;
        docEl.removeChild(fakeBody)
    &#125;
&#125;(windows,document))
</code></pre>
<h1 id="2-动画函数封装"><a href="#2-动画函数封装" class="headerlink" title="2. 动画函数封装"></a>2. 动画函数封装</h1><h2 id="2-1-动画实现原理"><a href="#2-1-动画实现原理" class="headerlink" title="2.1 动画实现原理"></a>2.1 动画实现原理</h2><ul>
<li><p>&#x3D;&#x3D;核心原理&#x3D;&#x3D;：通过&#x3D;&#x3D;定时器 setInterval()&#x3D;&#x3D; 不断移动盒子位置。</p>
</li>
<li><p>实现步骤：</p>
<ul>
<li>获得盒子当前位置</li>
<li>让盒子在当前位置加上 1 个移动距离</li>
<li>利用定时器不断重复这个操作</li>
<li>&#x3D;&#x3D;加上一个结束定时器的条件&#x3D;&#x3D;</li>
<li>注意此元素&#x3D;&#x3D;需要添加定位&#x3D;&#x3D;，才能使用 element.style.left</li>
</ul>
</li>
<li><p>代码实现</p>
<pre><code class="html">&lt;/head&gt;
    &lt;style&gt;
        div &#123;
            /* 一定要添加定位！！！ */
            position: absolute;
            left: 0;
            width: 100px;
            height: 100px;
            background-color: pink;
        &#125;
    &lt;/style&gt;
&lt;/head&gt;
&lt;/body&gt;
    &lt;div&gt;&lt;/div&gt;
    &lt;script&gt;
        // 1. 获取元素
        let div = document.querySelector(&#39;div&#39;);
        // 2. 获取元素当前位置,并移动;利用定时器不断重复这个操作
            // div.offsetLeft 是可读不可写的
        let timer = setInterval(function() &#123;
            // 3. 添加结束定时器的条件
            if(div.offsetLeft &gt;= 400) &#123;
                // 停止动画 本质是停止定时器
                clearInterval(timer);
            &#125;
            div.style.left = div.offsetLeft + 1 + &#39;px&#39;;
        &#125;,30);
    &lt;/script&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>
<h2 id="2-2-动画函数简单封装"><a href="#2-2-动画函数简单封装" class="headerlink" title="2.2 动画函数简单封装"></a>2.2 动画函数简单封装</h2><ul>
<li><p>注意函数需要传递两个参数，&#x3D;&#x3D;动画对象 obj&#x3D;&#x3D; 和 &#x3D;&#x3D;移动到的距离target&#x3D;&#x3D;</p>
</li>
<li><p>代码实现：</p>
<pre><code class="javascript">// 简单动画函数封装：obj目标对象，target 目标位置
function animate(obj,target) &#123;
    let timer = setInterval(function() &#123;
        if(obj.offsetLeft &gt;= target) &#123;
            // 停止动画 本质是停止定时器
            clearInterval(timer);
        &#125;
        obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;
    &#125;,30);
&#125;；
// 调用函数
let div = document.querySelector(&#39;div&#39;);
animate(div,400);
</code></pre>
</li>
</ul>
<h2 id="2-3-动画函数给不同元素记录不同定时器"><a href="#2-3-动画函数给不同元素记录不同定时器" class="headerlink" title="2.3 动画函数给不同元素记录不同定时器"></a>2.3 动画函数给不同元素记录不同定时器</h2><blockquote>
<p>&#x3D;&#x3D;如果多个元素都使用这个动画函数，每次都要 let 声明定时器&#x3D;&#x3D;。我们可以给不同的元素使用不同的定时器（自己专门用自己的定时器）</p>
</blockquote>
<ul>
<li><p>核心原理：利用 JS 是一门动态语言，可以很方便的给当前对象添加属性</p>
<pre><code class="javascript">let obj = &#123;&#125;;// 创建一个空对象
obj.name = &#39;andy&#39;;// 给空对象添加属性
</code></pre>
</li>
<li><p>代码实现：</p>
<pre><code class="javascript">// 简单动画函数封装：obj目标对象，target 目标位置
function animate(obj,target) &#123;
    // 当我们不断的点击按钮，这个元素的速度会越来越快，因为开启了太多的定时器
    // 解决方案就是 让我们元素只有一个定时器执行
    clearInterval(obj.timer);// 先清除以前的定时器，只保留当前的一个定时器执行
    
    // obj.timer 给不同的元素指定了不同的定时器
    obj.timer = setInterval(function() &#123;
        if(obj.offsetLeft &gt;= target) &#123;
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
        &#125;
        obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;
    &#125;,30);
&#125;；
// 点击 button 调用函数
let div = document.querySelector(&#39;div&#39;);
let btn = document.querySelector(&#39;button&#39;);
btn.addEventListener(&#39;click&#39;,function() &#123;
    animate(div,400);
&#125;)
</code></pre>
</li>
</ul>
<h2 id="2-4-缓动效果原理"><a href="#2-4-缓动效果原理" class="headerlink" title="2.4 缓动效果原理"></a>2.4 缓动效果原理</h2><blockquote>
<p>缓动动画就是&#x3D;&#x3D;让元素运动速度有所变化&#x3D;&#x3D;，最常见的是让速度慢慢停下来</p>
</blockquote>
<ul>
<li><p>思路</p>
<ul>
<li>让盒子每次移动的距离慢慢变小，速度就会慢慢落下来</li>
<li>核心算法：&#x3D;&#x3D;（目标值 - 现在的位置）&#x2F; 10，作为每次移动的距离步长&#x3D;&#x3D;</li>
<li>停止的条件：让当前盒子位置等于目标位置时就停止定时器</li>
<li>&#x3D;&#x3D;注意步长需要取整&#x3D;&#x3D; Math.ceil &#x2F; Math.floor<ul>
<li>&#x3D;&#x3D;若元素在两个值之间移动，则要通过判断步长值的正负来决定是向上还是向下取整&#x3D;&#x3D;：往右移动时 step &gt; 0 ，向大取整；往左移动时 step &lt; 0 ，向小取整；</li>
</ul>
</li>
</ul>
</li>
<li><p>缓动动画基本代码实现</p>
<pre><code class="javascript">function animate(obj,target) &#123;
    clearInterval(obj.timer);// 先清除以前的定时器，只保留当前的一个定时器执行
    obj.timer = setInterval(function() &#123;
        // 步长值写在定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题 Math.ceil 往大取整 Math.floor 向下取整
        let step = target - obj.offsetLeft) / 10;
        // 若元素在两个值之间移动，则要通过判断步长值的正负来决定是向上还是向下取整：往右移动时 step &gt; 0 ，向大取整；往左移动时 step &lt; 0 ，向小取整；
        step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if(obj.offsetLeft &gt;= target) &#123;
            clearInterval(obj.timer);
        &#125;
        // 把每次加 1 这个步长值改为一个慢慢变小的值  步长公式：（目标值 - 现在的位置）/ 10
        obj.style.left = obj.offsetLeft + step + &#39;px&#39;;
    &#125;,30);
&#125;；

// 调用函数
let btn500 = document.querySelector(&#39;.btn500&#39;);
let btn500 = document.querySelector(&#39;.btn500&#39;);
</code></pre>
</li>
</ul>
<h2 id="2-5-动画函数添加回调函数"><a href="#2-5-动画函数添加回调函数" class="headerlink" title="2.5 动画函数添加回调函数"></a>2.5 动画函数添加回调函数</h2><ul>
<li><p>&#x3D;&#x3D;回调函数原理&#x3D;&#x3D;：函数可以作为一个参数。将这个函数作为参数传到另一个函数里面，当那个函数执行完后，在执行传进去的这个函数，这个过程就叫做&#x3D;&#x3D;回调&#x3D;&#x3D;</p>
</li>
<li><p>案例：当 box 移动到 200px 时，颜色改为 purple</p>
<pre><code class="javascript">let div = document.querySelector(&#39;div&#39;);
function animate(obj,target,callback) &#123;
    clearInterval(obj.timer);
    obj.timer = setInterval(function() &#123;
        obj.style.left = obj.offsetLeft + 1 + &#39;px&#39;;
        if (obj.offsetLeft &gt;= target) &#123;
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            // 定时器结束完了再执行的函数  回调函数
            if(callback) &#123;
            // 调用函数
            callback();
            &#125;
        &#125;
    &#125;,30)
&#125;;
animate(div,200,function() &#123;
    div.style.backgroundColor = &#39;purple&#39;
&#125;);
</code></pre>
</li>
</ul>
<h2 id="2-6-动画函数封装到单独-JS-文件里面"><a href="#2-6-动画函数封装到单独-JS-文件里面" class="headerlink" title="2.6 动画函数封装到单独 JS 文件里面"></a>2.6 动画函数封装到单独 JS 文件里面</h2><blockquote>
<p>因为以后经常使用这个动画函数，可以单独封装到一个 JS 文件里面，使用的时候引用这个文件即可。</p>
</blockquote>
<h3 id="2-6-1-封装-animate-缓动动画函数"><a href="#2-6-1-封装-animate-缓动动画函数" class="headerlink" title="2.6.1 封装 animate 缓动动画函数"></a>2.6.1 封装 animate 缓动动画函数</h3><pre><code class="javascript">function animate(obj, target, callback) &#123;
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function () &#123;
        // 步长值写到定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题
        // var step = Math.ceil((target - obj.offsetLeft) / 10);
        let step = (target - obj.offsetLeft) / 10;
        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if (obj.offsetLeft == target) &#123;
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            callback &amp;&amp; callback(); // 相当于 if callback &#123;callback()&#125;;
        &#125;
        // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
        obj.style.left = obj.offsetLeft + step + &#39;px&#39;;
    &#125;, 15);
&#125;
</code></pre>
<h3 id="2-6-3-调用-animate-函数实例"><a href="#2-6-3-调用-animate-函数实例" class="headerlink" title="2.6.3 调用 animate 函数实例"></a>2.6.3 调用 animate 函数实例</h3><ul>
<li><p>要求实现效果如图</p>
<ul>
<li><p>收缩状态</p>
<ul>
<li>箭头向左</li>
</ul>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E6%94%B6%E7%BC%A9%E7%8A%B6%E6%80%81.png"></p>
</li>
<li><p>弹出状态</p>
<ul>
<li>箭头向右</li>
</ul>
<p><img src="https://gitee.com/colohh/image_bed/raw/master/img/%E5%BC%B9%E5%87%BA%E7%8A%B6%E6%80%81.png"></p>
</li>
</ul>
</li>
<li><p>代码实现</p>
<pre><code class="html">&lt;head&gt;
    /* 引入 JS 文件 */ 
    &lt;script src=&quot;animate.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;div class=&quot;sliderbar&quot;&gt;
    &lt;span&gt;←&lt;/span&gt;
    &lt;div class=&quot;con&quot;&gt;问题反馈&lt;/div&gt;
&lt;/div&gt;
&lt;script&gt;
    // 1. 获取元素
    let sliderbar = document.querySelector(&#39;.sliderbar&#39;);
    let con = document.querySelector(&#39;.con&#39;);
    let span = document.querySelector(&#39;span&#39;);
    // 当鼠标经过 sliderbar 就会让 con 这个盒子滑动到左侧
    // mouseenter 没有冒泡
    sliderbar.addEventListener(&#39;mouseenter&#39;,function() &#123;
        // animate(obj,target,callback);
        animate(con,-160,function() &#123;
            // 当动画执行完毕 就把左箭头改为右箭头
            span.innerHTML = &#39;→&#39;;
        &#125;);
    &#125;)
    // 当鼠标经过 sliderbar 就会让 con 这个盒子滑动到右侧
    sliderbar.addEventListener(&#39;mouseleave&#39;,function() &#123;
        // animate(obj,target,callback);
        animate(con,0,function() &#123;
            // 当动画执行完毕 就把右箭头改为左箭头
            span.innerHTML = &#39;←&#39;;
        &#125;);
    &#125;)
&lt;/script&gt;
</code></pre>
</li>
</ul>
<h1 id="3-常见网页特效案例"><a href="#3-常见网页特效案例" class="headerlink" title="3. 常见网页特效案例"></a>3. 常见网页特效案例</h1><h2 id="3-1-网页轮播图"><a href="#3-1-网页轮播图" class="headerlink" title="3.1 网页轮播图"></a>3.1 网页轮播图</h2><h3 id="3-1-1-功能需求"><a href="#3-1-1-功能需求" class="headerlink" title="3.1.1 功能需求"></a>3.1.1 功能需求</h3><ul>
<li>鼠标经过轮播图模块，左右按钮显示，鼠标离开隐藏左右按钮。</li>
<li>点击右侧按钮一次，图片往左播放一张，以此类推，左侧按钮同理。</li>
<li>图片播放的同时，下面小圆点模块跟随一起变化。</li>
<li>点击小圆点，可以播放相应图片。</li>
<li>鼠标不经过轮播图，轮播图也会自动播放照片。</li>
<li>鼠标经过，轮播图模块自动停止播放。</li>
</ul>
<h3 id="3-1-2-代码实现"><a href="#3-1-2-代码实现" class="headerlink" title="3.1.2 代码实现"></a>3.1.2 代码实现</h3><ul>
<li><p>index.html</p>
<pre><code class="html">&lt;head&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * &#123;
            margin: 0;
            padding: 0
        &#125;
        li &#123;
            list-style: none;
        &#125;
        a &#123;
            color: #666;
            text-decoration: none;
        &#125;


        .focus &#123;
            position: relative;
            width: 721px;
            height: 455px;
            margin: 0 auto;
            overflow: hidden;
        &#125;
        .arrow-l,
        .arrow-r &#123;
            display: none;
            position: absolute;
            top: 50%;
            margin-top: -20px;
            width: 24px;
            height: 40px;
            background-color: rgba(0, 0, 0, .3);
            text-align: center;
            line-height: 40px;
            color: #fff;
            font-size: 18px;
            z-index: 2;
        &#125;
        .arrow-r &#123;
            right: 0;
        &#125;
        .circle &#123;
            position: absolute;
            bottom: 10px;
            left: 50px;
        &#125;
        .circle li &#123;
            float: left;
            width: 8px;
            height: 8px;
            border: 2px solid rgba(255, 255, 255, .5);
            margin: 0 3px;
            border-radius: 50%;
            cursor: pointer;
        &#125;
        .current &#123;
            /* 被选中的小圆点 */
            background-color: #fff;
        &#125;
        .focus ul &#123;
            /* 使所有轮播图在一行上 */
            /* 必须有定位才能使用动画函数 */
            position: absolute;
            top: 0;
            left: 0;
            width: 500%;
        &#125;
        .focus ul li &#123;
            float: left;
        &#125;
    &lt;/style&gt;
    &lt;!-- 引入 animate.js --&gt;
    &lt;script src=&quot;js/animate.js&quot;&gt;&lt;/script&gt;
    &lt;!-- 引入 首页的 js 文件 --&gt;
    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div class=&quot;focus fl&quot;&gt;
        &lt;!-- 左侧按钮 --&gt;
        &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-l&quot;&gt;
            &lt;!-- &amp;lt 表示左半括号 &lt; --&gt;
            &amp;lt;
        &lt;/a&gt;
        &lt;!-- 右侧按钮 --&gt;
        &lt;a href=&quot;javascript:;&quot; class=&quot;arrow-r&quot;&gt;
            &lt;!-- 用 &amp;gt 表示右半括号 &gt; --&gt;
            &amp;gt;
        &lt;/a&gt;

        &lt;!-- 核心的滚动区域 --&gt;
        &lt;ul&gt;
            &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus1.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
            &lt;/li&gt;            
            &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus2.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
            &lt;/li&gt;
            &lt;li&gt;
                &lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;upload/focus3.jpg&quot; alt=&quot;&quot;&gt;&lt;/a&gt;
            &lt;/li&gt;
        &lt;/ul&gt;

        &lt;!-- 小圆点 --&gt;
        &lt;ol class=&quot;circle&quot;&gt;

        &lt;/ol&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
</li>
<li><p>index.js</p>
<pre><code class="javascript">// 因为 JS 较多，我们单独新建 js 文件，引入页面中。
// 此时需要添加 load 事件（全部加载完成后执行）

window.addEventListener(&#39;load&#39;, function () &#123;
    // 1. 获取元素
    let arrow_l = document.querySelector(&#39;.arrow-l&#39;);
    let arrow_r = document.querySelector(&#39;.arrow-r&#39;);
    let focus = this.document.querySelector(&#39;.focus&#39;);
    let focusWidth = focus.offsetWidth;
    // 2. 鼠标经过focus 就显示左右按钮
    focus.addEventListener(&#39;mouseenter&#39;, function () &#123;
            arrow_l.style.display = &#39;block&#39;;
            arrow_r.style.display = &#39;block&#39;;
            // 鼠标经过停止轮播                                                             
            clearInterval(timer);
            timer = null;//清除定时器变量
        &#125;);
    // 鼠标离开focus 就隐藏左右按钮
    focus.addEventListener(&#39;mouseleave&#39;, function () &#123;
        arrow_l.style.display = &#39;none&#39;;
        arrow_r.style.display = &#39;none&#39;;
        timer = setInterval(function() &#123;
            //手动调用点击事件
            arrow_r.click();
        &#125;, 2000);
    &#125;);

    // 3. 动态生成小圆点
    let ul = focus.querySelector(&#39;ul&#39;);
    let ol = focus.querySelector(&#39;.circle&#39;)
    // focus.ul 里有多少个 li 我们就创建多少个小圆点
    // console.log(ul.children.length);
    for (let i = 0; i &lt; ul.children.length; i++) &#123;
        // 创建一个 li
        let li = document.createElement(&#39;li&#39;);
        // 记录当前小圆点的索引号 通过自定义属性来做
        li.setAttribute(&#39;index&#39;,i);
        // 把 li 插入到 ol 里
        ol.appendChild(li);

        // 4. 小圆点的排他思想 生成小圆点的同时绑定点击事件
        li.addEventListener(&#39;click&#39;, function () &#123;
            // 干掉所有人 把所有的 li 清除 current 类名
            for (let i = 0; i &lt; ol.children.length; i++) &#123;
                ol.children[i].className = &#39;&#39;;
            &#125;
            // 留下我自己 当前的 li 设置 current 类名
            this.className = &#39;current&#39;;
            // 5. 点击小圆圈移动图片 此时移动的是 ul
            // ul 的移动距离就是 小圆点的索引号 乘以 图片的宽度
            // 当我们点击了某个 li 就拿到当前 li 的索引号
            let index = this.getAttribute(&#39;index&#39;);
            // 当我们点击了某个 li，就要把这个 li 的索引号给 num
            num = index;
            // 当我们点击了某个 li，就要把这个 li 的索引号给 circle
            circle = index;
            // 调用函数
            animate(ul,-index * focusWidth);
        &#125;)
    &#125;
    // 把 ol 里面的第一个 li 设置类名为 current
    ol.children[0].className = &#39;current&#39;;
    // 6. 克隆第一张图片（li），放到 ul 最后面
        // cloneNode(true) 为深克隆 可以克隆原节点及其子节点
    let first = ul.children[0].cloneNode(true);
    ul.appendChild(first);
    
    // 7. 点击右侧按钮，图片滚动一张
        // 图片滚动原理：①把 ul 第一个 li 复制一份，放到 ul 的最后面；②当图片滚动到克隆的最后一张照片时，让 ul 快速的、不做动画的跳到最左侧：left 为 0
    let num = 0;
    // circle 控制小圆点的播放
    let circle = 0;
    // flag 节流阀
    let flag = true;
    arrow_r.addEventListener(&#39;click&#39;,function() &#123;
        if(flag) &#123;// 节流阀开启时才能执行
            flag = false;// 关闭节流阀
            // 声明一个变量 num，点击一次自增 1，让这个变量乘以图片宽度，就是 ul 的滚动距离
            // 如果走到了最后复制的一张图片，此时 我们的 ul 要快速复原 left 改为 0 
            if(num == ul.children.length - 1) &#123;
                ul.style.left = 0;
                num = 0;
            &#125;
            num++;
            animate(ul,-num*focusWidth,function() &#123;
                flag = true;// 回调函数 开启节流阀
            &#125;);
            // 8. 点击右侧按钮，小圆点跟随一起变化，可以声明一个变量 circle 控制小圆点的播放
            circle++;
            // 如果circle == ol.children.length 说明我们走到克隆的这张图片了 我们就复原
            if(circle == ol.children.length) &#123;
                circle = 0;
            &#125;
            // 调用函数 修改圆点样式
            circleChange();
            &#125;
    &#125;)

    // 9. 左侧按钮做法
    arrow_l.addEventListener(&#39;click&#39;,function() &#123;
        if(flag) &#123;
            flag = false;// 关闭节流阀
        // 如果走到了第一张图片，此时 我们的 ul 要快速复原 left 为最后一张复制的图片左侧
            if(num == 0) &#123;
                num = ul.children.length - 1;
                ul.style.left = -num * focusWidth + &#39;px&#39;;
            &#125;
            num--;
            // 可以把ul理解为一把尺子 向左向右靠移动的是大小 而符号不变 总的来说都是往左移动
            animate(ul,-num * focusWidth,function() &#123;
                flag = true;// 开启节流阀
            &#125;);
            // 点击左侧按钮，小圆点跟随一起变化，可以声明一个变量 circle 控制小圆点的播放
            circle--;
            // 如果circle &lt; 0 说明第一张图片了 小圆点要改为第四个小圆点
            // if(circle &lt; 0) &#123;
            //     circle = ol.children.length - 1;
            // &#125;
            circle &lt; 0 ? ol.children.length - 1 : circle;
            // 调用函数 修改圆点样式
            circleChange();	
        &#125;
    &#125;)

    // 封装一个函数 用来修改圆点样式
    function circleChange() &#123;
        // 排他思想：
        // 先清除其他小圆点的类名
        for(let i = 0; i &lt; ol.children.length; i++) &#123;
            ol.children[i].className = &#39;&#39;;
        &#125;
        // 留下当前的小圆点类名
        ol.children[circle].className = &#39;current&#39;;
    &#125;

    // 10.自动播放轮播图
    let timer = this.setInterval(function() &#123;
        // 手动调用点击事件
        arrow_r.click();
    &#125;,2000)
&#125;)
</code></pre>
</li>
</ul>
<h2 id="3-2-节流阀"><a href="#3-2-节流阀" class="headerlink" title="3.2 节流阀"></a>3.2 节流阀</h2><blockquote>
<p>&#x3D;&#x3D;防止轮播图&#x3D;&#x3D;连续点击造成&#x3D;&#x3D;播放过快&#x3D;&#x3D;。</p>
<p>节流阀目的：&#x3D;&#x3D;当上一个函数动画内容执行完毕，再去执行下一个函数动画&#x3D;&#x3D;，让事件无法连续触发。</p>
<p>核心实现思路：利用&#x3D;&#x3D;回调函数&#x3D;&#x3D;，添加一个变量来控制，锁住函数和解锁函数。</p>
</blockquote>
<h3 id="3-2-1-代码实现"><a href="#3-2-1-代码实现" class="headerlink" title="3.2.1 代码实现"></a>3.2.1 代码实现</h3><pre><code class="javascript">// flag 节流阀
let flag = true;
btn.addEventListener(&#39;click&#39;,function() &#123;
    if(flag) &#123; // 节流阀开启时才能执行
        flag = false;// 关闭节流阀
        animate(obj,target,function() &#123;
            flag = true;// 回调函数 开启节流阀
        &#125;)
    &#125;
&#125;)
</code></pre>
<h2 id="3-3-返回顶部功能"><a href="#3-3-返回顶部功能" class="headerlink" title="3.3 返回顶部功能"></a>3.3 返回顶部功能</h2><ul>
<li><p>滚动窗口至文档中的特定位置</p>
<ul>
<li>window.scroll(x,y)</li>
</ul>
</li>
<li><p>功能代码实现</p>
<pre><code class="javascript">goBack.addEventListener(&#39;click&#39;,function() &#123;
    window.scroll(0,0);
&#125;)
</code></pre>
</li>
<li><p>带有动画缓慢的返回顶部</p>
<ul>
<li><p>需要用到我们之前封装的 animate 函数，但需要把左右改为上下</p>
</li>
<li><p>代码实现</p>
<pre><code class="javascript">// 返回顶部
// 滚动窗口至文档中的特定位置 window.scroll(x,y)
goBack.addEventListener(&#39;click&#39;,function() &#123;
    animate(window,0);
&#125;);
// 动画函数
function animate(obj, target, callback) &#123;
    // 先清除以前的定时器，只保留当前的一个定时器执行
    clearInterval(obj.timer);
    obj.timer = setInterval(function () &#123;
        // 步长值写到定时器的里面
        // 把我们步长值改为整数 不要出现小数的问题
        let step = (target - window.pageYOffset) / 10;
        step = step &gt; 0 ? Math.ceil(step) : Math.floor(step);
        if (window.pageYOffset == target) &#123;
            // 停止动画 本质是停止定时器
            clearInterval(obj.timer);
            // 回调函数写到定时器结束里面
            if (callback) &#123;
                // 调用函数
                callback();
            &#125;
            // 这里的callback &amp;&amp; callback(data);相当于 if callback &#123;callback()&#125;;
            // callback &amp;&amp; callback();
        &#125;
    // 把每次加1 这个步长值改为一个慢慢变小的值  步长公式：(目标值 - 现在的位置) / 10
    // obj.style.top = window.pageYOffset + step + &#39;px&#39;;
        window.scroll(0,window.pageYOffset + step);
    &#125;,15);
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="3-4-筋斗云导航栏"><a href="#3-4-筋斗云导航栏" class="headerlink" title="3.4 筋斗云导航栏"></a>3.4 筋斗云导航栏</h2><h3 id="3-4-1-案例需求"><a href="#3-4-1-案例需求" class="headerlink" title="3.4.1 案例需求"></a>3.4.1 案例需求</h3><ul>
<li>鼠标经过某个 li ，筋斗云跟着到当前 li 的位置</li>
<li>鼠标离开这个 li ，筋斗云复原为原来的位置</li>
<li>鼠标点击了某个 li，筋斗云就会停留在点击的这个 li 的位置</li>
</ul>
<h3 id="3-4-2-代码实现"><a href="#3-4-2-代码实现" class="headerlink" title="3.4.2 代码实现"></a>3.4.2 代码实现</h3><ul>
<li><p>index.js</p>
<pre><code class="javascript">window.addEventListener(&#39;load&#39;,function() &#123;
    // 1.获取元素
    let cloud = document.querySelector(&#39;.cloud&#39;);
    let c_nav = document.querySelector(&#39;.c-nav&#39;);
    let lis = c_nav.querySelectorAll(&#39;li&#39;);
    // 2.给所有的 li 绑定事件
    // 这个 current 作为筋斗云的起始位置
    let current = 0;
        // （1）鼠标经过哪个 li 筋斗云则移动到哪里
    for (let i = 0; i &lt; lis.length; i++) &#123;
        lis[i].addEventListener(&#39;mouseenter&#39;,function() &#123;
            animate(cloud,this.offsetLeft)
        &#125;);
        // （2）鼠标离开 则筋斗云回到起始的位置
        lis[i].addEventListener(&#39;mouseleave&#39;,function() &#123;
            animate(cloud,current)
        &#125;);
        // （3）鼠标点击某个 li ，就把当前位置作为目标值
        lis[i].addEventListener(&#39;click&#39;,function()&#123;
            current = this.offsetLeft;
        &#125;)
    &#125;    
&#125;)
</code></pre>
</li>
<li><p>index.html</p>
<pre><code class="html">&lt;head&gt;
    &lt;title&gt;Document&lt;/title&gt;
    &lt;style&gt;
        * &#123;
            padding: 0;
            margin: 0;
        &#125;
        ul &#123;
            list-style: none;
        &#125;
        a &#123;
            text-decoration: none;
            color: #333;
        &#125;
        body &#123;
            background-color: black;
        &#125;
        .c-nav &#123;
            position: relative;
            width: 900px;
            height: 42px;
            background: #fff url(images/rss.png) no-repeat right center;
            margin: 100px auto;
            border-radius: 5px;
        &#125;
        .c-nav ul &#123;
            position: absolute;
        &#125;
        .c-nav li &#123;
            float: left;
            width: 83px;
            text-align: center;
            line-height: 42px;
        &#125;
        .c-nav li a:hover &#123;
            color: white;
        &#125;
        .cloud &#123;
            position: absolute;
            left: 0;
            top: 0;
            width: 83px;
            height: 42px;
            background: url(images/cloud.gif) no-repeat;
        &#125;
    &lt;/style&gt;
    &lt;script src=&quot;js/animate.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;js/index.js&quot;&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;div id=&quot;c_nav&quot; class=&quot;c-nav&quot;&gt;
        &lt;span class=&quot;cloud&quot;&gt;&lt;/span&gt;
        &lt;ul&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot; style=&quot;color: #0dff1d;&quot;&gt;首页新闻&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;师资力量&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;活动策划&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;企业文化&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;招聘信息&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;公司简介&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;哈喽哈喽&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href=&quot;#&quot;&gt;嘿嘿哈嘿&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;
    &lt;/div&gt;
&lt;/body&gt;
</code></pre>
</li>
</ul>

  </div>
  <div id="gitalk-container"></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging">
    
    <a href="/2022/11/11/JavaScript%E5%9F%BA%E7%A1%80/">
        <div class="post-paging-last">
            <span>上一篇</span>
            <p>JavaScript基础</p>
        </div>
    </a>
    

    
    <a href="/2022/11/11/JavaScript%E9%AB%98%E7%BA%A7/">
        <div class="post-paging-next">
            <span>下一篇</span>
            <p>JavaScript高级</p>
        </div>
    </a>
    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2022 By sheep. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/79e/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?94ea92e08139a609b3e9a9fd82080c82";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"f9b10e7298e1a0d041ea","clientSecret":"ed9c807b5965710c6636de27d7972668257d348c","repo":"myblogtalk","owner":"sheep1005","admin":"sheep1005"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('true')){
            gitalk.render('gitalk-container')
        }
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>

