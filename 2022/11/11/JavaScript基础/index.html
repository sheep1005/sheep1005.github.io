<!DOCTYPE html>
<html>
	<head>
		
<title>JavaScript基础-hi</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="前端,学习笔记,JavaScript,">
<meta name="description" content="很简单啦">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.highlightAll();</script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>sheep</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 66%;
        height: 100%;
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815);
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					right: "0"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					right: "-100%"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-color"
    style="background: url('')" 
>
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
            
            <li><a href="/tags/前端">前端</a></li>
            
            <li><a href="/tags/学习笔记">学习笔记</a></li>
            
            <li><a href="/tags/JavaScript">JavaScript</a></li>
            
            
        </ul>
        
        <h1>JavaScript基础</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                        <g>
                            <path fill="#12183A"
                                d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                            </path>
                        </g>
                    </svg>
                
                <span class="post-header-info-author-text"> <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">Sheep</a></span>
                <div class="post-header-info-author-categories">
                    
                         <a href="../../categories/JavaScript/" target="_blank" >JavaScript</a>
                    
                </div>
                <p>2022-11-11 20:33:36</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1><h2 id="1-JavaScript简介"><a href="#1-JavaScript简介" class="headerlink" title="1. JavaScript简介"></a>1. JavaScript简介</h2><ul>
<li>JavaScript，就是我们通常所说的JS，是一种嵌入到HTML页面中的&#x3D;&#x3D;脚本语言&#x3D;&#x3D;，由浏览器一边解释一边执行。</li>
<li>“HTML是网页的结构，CSS是网页的外观，而JavaScript是页面的行为。”</li>
</ul>
<h2 id="2-JavaScript的特点"><a href="#2-JavaScript的特点" class="headerlink" title="2. JavaScript的特点"></a>2. JavaScript的特点</h2><ul>
<li><p><strong>动态改变页面内容</strong></p>
<blockquote>
<p>HTML页面是静态的，一旦编写，内容是无法改变的。JavaScript可以弥补这个不足，可以将内容&#x3D;&#x3D;动态&#x3D;&#x3D;地显示在网页中。</p>
</blockquote>
</li>
<li><p><strong>动态改变网页的外观</strong></p>
<blockquote>
<p>JavaScript通过修改网页元素的CSS样式，达到动态地改变网页的外观。</p>
</blockquote>
</li>
<li><p><strong>验证表单数据</strong></p>
<blockquote>
<p>我们常见的在各大网站中的注册中的验证功能，就是JavaScript实现的。</p>
</blockquote>
</li>
<li><p><strong>响应事件</strong></p>
<blockquote>
<p>JavaScript是基于事件的语言。例如点击一个按钮弹出一个对话框，就是鼠标点击触发的事件。</p>
</blockquote>
</li>
</ul>
<p>对于JavaScript的理解，就一句话：如果没有使用JavaScript，网页就是静态的，唯一的功能就是给用户浏览。加入了JavaScript，网页变得绚丽多彩起来。</p>
<h2 id="3-JavaScript入门基础"><a href="#3-JavaScript入门基础" class="headerlink" title="3. JavaScript入门基础"></a>3. JavaScript入门基础</h2><h3 id="3-1-Javascript基本使用"><a href="#3-1-Javascript基本使用" class="headerlink" title="3.1  Javascript基本使用"></a>3.1  Javascript基本使用</h3><h4 id="3-1-1-JavaScript在HTML的引用方式"><a href="#3-1-1-JavaScript在HTML的引用方式" class="headerlink" title="3.1.1  JavaScript在HTML的引用方式"></a>3.1.1  JavaScript在HTML的引用方式</h4><p>（1）<strong>页头引入</strong>（head标签内）； </p>
<pre><code class="HTML">&lt;script&gt;
     alert(&#39;沙漠骆驼&#39;)
&lt;/script&gt;
</code></pre>
<p>（2）页中引入（body标签内）；</p>
<p>（3）元素事件中引入（标签属性中引入）；</p>
<pre><code class="HTML">&lt;input type=&quot;button&quot; value=&quot;唐伯虎&quot; onclick=&quot;alert(&#39;秋香姐&#39;)&quot;&gt;
</code></pre>
<p>（4）<strong>引入外部JS文件</strong> （script之间不可以再写东西了）；</p>
<pre><code class="HTML">&lt;script src=&quot;my.js&quot;&gt;&lt;/script&gt;
</code></pre>
<h4 id="3-1-2-注释"><a href="#3-1-2-注释" class="headerlink" title="3.1.2  注释"></a>3.1.2  注释</h4><ol>
<li>单行注释 ctrl + &#x2F;</li>
<li>多行注释  shift + alt + a<blockquote>
<p>多行注释  vscode中修改多行注释的快捷键： ctrl + shift + &#x2F;</p>
</blockquote>
</li>
</ol>
<h4 id="3-1-3-输入输出语句"><a href="#3-1-3-输入输出语句" class="headerlink" title="3.1.3  输入输出语句"></a>3.1.3  输入输出语句</h4><ul>
<li><p>prompt 输入框</p>
<pre><code class="javascript">
prompt(&#39;请输入您的年龄&#39;);
</code></pre>
</li>
<li><p>alert 弹出警示框 输出的 展示给用户的</p>
<pre><code class="javascript">alert(&#39;计算的结果是&#39;)
</code></pre>
</li>
<li><p>console 控制台输出 给程序员测试用的</p>
<pre><code class="javascript">console.log(&#39;我是程序员能看到的&#39;)
</code></pre>
</li>
</ul>
<h3 id="3-2-Javascript数据结构"><a href="#3-2-Javascript数据结构" class="headerlink" title="3.2 Javascript数据结构"></a>3.2 Javascript数据结构</h3><p>JavaScript的数据结构包括：<strong>标识符</strong>、<strong>关键字</strong>、<strong>常量</strong>、<strong>变量</strong>等。</p>
<h4 id="1-标识符"><a href="#1-标识符" class="headerlink" title="1. 标识符"></a>1. 标识符</h4><ul>
<li><p>标识符，说白了，就是一个名字。在JavaScript中，变量和函数等都需要定义一个名字，这个名字就可以称为“标识符”。</p>
</li>
<li><p>命名规范：</p>
</li>
</ul>
<blockquote>
<p>（1）第一个字符必须是字母、下划线（_）或美元符号这3种其中之一，其后的字符可以是字母、数字或下划线、美元符号；</p>
<p>（2）变量名不能包含空格、加号、减号等符号；</p>
<p>（3）标识符不能和JavaScript中用于其他目的的关键字同名；</p>
</blockquote>
<h4 id="2-关键字"><a href="#2-关键字" class="headerlink" title="2. 关键字"></a>2. 关键字</h4><p>JavaScript关键字是指在JavaScript语言中有特定含义，成为JavaScript语法中一部分的那些字。</p>
<h4 id="3-常量"><a href="#3-常量" class="headerlink" title="3. 常量"></a>3. 常量</h4><p>常量主要用于为程序提供固定和精确的值，包括数值和字符串，如数字、逻辑值真（true）、逻辑值假（false）等都是常量。</p>
<h4 id="4-变量"><a href="#4-变量" class="headerlink" title="4. 变量"></a>4. 变量</h4><p>变量，顾名思义，就是指在程序运行过程中，其值是可以改变的。</p>
<ul>
<li><p>声明和赋值</p>
<ul>
<li><p>声明了一个age变量<br>  <code>var age;</code></p>
</li>
<li><p>声明了一个age变量<br><code>age = 18;</code></p>
</li>
<li><p>输出结果<br><code>console.log(age);</code></p>
</li>
<li><p>变量的初始化</p>
<pre><code class="javascript">let myname = &#39;sheep&#39;;
console.log(myname);
</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>声明变量的特殊情况</p>
<ul>
<li><p>只声明不赋值 结果是 undefined 未定义的</p>
<pre><code class="javascript">let sex;
console.log(sex);
</code></pre>
</li>
<li><p>不声明不赋值 直接使用某个变量会报错</p>
<p><code>console.log(tel);</code></p>
</li>
<li><p>不声明直接赋值使用 </p>
<pre><code class="javascript">qq = 110;
console.log(qq);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="5-声明变量-let"><a href="#5-声明变量-let" class="headerlink" title="5. 声明变量 let"></a>5. 声明变量 let</h4><h5 id="1-let介绍"><a href="#1-let介绍" class="headerlink" title="(1) let介绍"></a>(1) let介绍</h5><p>ES6引入了let,用let声明变量，解决了JavaScript没有块级作用域的问题（注:ES3的catch分句会产生块作用域）。</p>
<h5 id="2-作用域"><a href="#2-作用域" class="headerlink" title="(2) 作用域"></a>(2) 作用域</h5><blockquote>
<p>作用域简单的来说，就是一套寻找变量的规则，用于确定在何处以及如何查找变量</p>
</blockquote>
<ul>
<li>当一个块或函数嵌套在另一个函数时，就发生了&#x3D;&#x3D;作用域嵌套&#x3D;&#x3D;&#x3D;。如图所示，就有三个嵌套作用域：<ul>
<li>全局作用域，其中有一个标识符:foo（整个绿色区域）</li>
<li>foo创建的函数作用域,其中有三个标识符：a,bar和b（整个黄色区域）</li>
<li>bar创建的函数作用域，其中有一个标识符：c（蓝色区域）</li>
</ul>
</li>
</ul>
<img src="E:\sheep\study\notes\images\嵌套作用域.png" alt="嵌套作用域" style="zoom: 50%;" />

<ul>
<li>如何在嵌套作用域中寻找变量呢：引擎&#x3D;&#x3D;从当前作用域开始查找&#x3D;&#x3D;变量，如果找不到，就会向&#x3D;&#x3D;上一级&#x3D;&#x3D;继续查找。当抵达最外层全局作用域时，无论找到还是没有找到，查找过程中都会停止。</li>
</ul>
<h5 id="3-let-特点"><a href="#3-let-特点" class="headerlink" title="(3) let 特点"></a>(3) let 特点</h5><ul>
<li><p>作用域只在他所在的代码块</p>
<pre><code class="javascript">for(let i = 0 ; i&lt;5 ; i++) &#123;
    let i = &#39;cht&#39;;
    console.log(i); // cht *5
&#125;
// console.log(i); //Error:i is not defined
</code></pre>
</li>
<li><p>let 不允许在相同的作用域内，重复声明同一个变量</p>
</li>
<li><p>let 声明不使用会报错</p>
</li>
<li><p>不存在变量提升</p>
<blockquote>
<p>ES6明确规定，如果区块中存在let&#x2F;const命令，这个区块用这些命令声明的变量，从一开始就形成了封闭作用域。&#x3D;&#x3D;凡是在声明之前就使用的变量，就会报错&#x3D;&#x3D;</p>
</blockquote>
</li>
<li><p>外层作用域不能访问内层变量；内层变量可访问外层变量。</p>
</li>
<li><p>不影响作用域链</p>
<pre><code class="javascript">&#123;
    let school = &#39;china&#39;;
    function fn()&#123;
    console.log(school);
    &#125;
    fn();// china
&#125;
</code></pre>
</li>
</ul>
<h3 id="3-3-JavaScript数据类型"><a href="#3-3-JavaScript数据类型" class="headerlink" title="3.3 JavaScript数据类型"></a>3.3 JavaScript数据类型</h3><blockquote>
<p>js是动态语言，变量的数据类型是可以变化的。只有程序在运行过程中，根据等号右边的值来确定</p>
</blockquote>
<h5 id="3-3-1-基本数据类型："><a href="#3-3-1-基本数据类型：" class="headerlink" title="3.3.1 基本数据类型："></a>3.3.1 基本数据类型：</h5><h6 id="（1）数字型（Number型）：如整型84，浮点型3-14；"><a href="#（1）数字型（Number型）：如整型84，浮点型3-14；" class="headerlink" title="（1）数字型（Number型）：如整型84，浮点型3.14；"></a>（1）数字型（Number型）：如整型84，浮点型3.14；</h6><pre><code class="javascript">let num = 10; // num 数字型 
let PI = 3.14 // PI 数字型
</code></pre>
<ul>
<li><ol>
<li><p>八进制  0 ~ 7  我们程序里面数字前面加0 表示八进制</p>
<pre><code class="javascript">let num1 = 010;
console.log(num1); //  010  八进制 转换为 10进制 就是  8 
</code></pre>
</li>
</ol>
</li>
<li><ol start="2">
<li><p>十六进制  0 ~ 9  a ~ f    #ffffff  数字的前面加 0x 表示十六进制</p>
<pre><code class="javascript">var num3 = 0x9;
console.log(num3);
</code></pre>
</li>
</ol>
</li>
<li><ol start="3">
<li>数字型的最大值<br>   <code>console.log(Number.MAX_VALUE);</code></li>
</ol>
</li>
<li><ol start="4">
<li>数字型的最小值<br>   <code>console.log(Number.MIN_VALUE);</code></li>
</ol>
</li>
<li><ol start="5">
<li>无穷大<br>   <code>console.log(Number.MAX_VALUE * 2); // Infinity 无穷大</code></li>
</ol>
</li>
<li><ol start="6">
<li>无穷小<br>   <code>console.log(-Number.MAX_VALUE * 2); // -Infinity 无穷大</code></li>
</ol>
</li>
<li><ol start="7">
<li>非数字<br>   <code>console.log(&#39;pink老师&#39; - 100); // NaN</code><blockquote>
<p><strong>isNaN()</strong> 这个方法用来判断非数字   并且返回一个值 如果是数字返回的是 false 如果不是数字返回的是true</p>
</blockquote>
</li>
</ol>
</li>
</ul>
<pre><code class="javascript">    console.log(isNaN(12)); // false
    console.log(isNaN(&#39;pink老师&#39;)); // true
</code></pre>
<h6 id="（2）字符串型（String型）：如”pink”；"><a href="#（2）字符串型（String型）：如”pink”；" class="headerlink" title="（2）字符串型（String型）：如”pink”；"></a>（2）字符串型（String型）：如”pink”；</h6><p>字符串的拼接：</p>
<ul>
<li><ol>
<li>检测获取字符串的长度 <strong>变量名.length</strong></li>
</ol>
</li>
</ul>
<pre><code class="javascript">        let str = &#39;my name is andy&#39;;
        console.log(str.length);//15
</code></pre>
<ul>
<li><ol start="2">
<li>字符串的拼接 <strong>+</strong></li>
</ol>
</li>
</ul>
<pre><code class="javascript">        console.log(&#39;hello&#39;+&#39; &#39;+&#39;world&#39;);
        console.log(&#39;618&#39;+&#39;大促&#39;);
</code></pre>
<blockquote>
<p>注意：&#x3D;&#x3D;字符串+其他类型 最后结果也一定是字符串型&#x3D;&#x3D;</p>
</blockquote>
<pre><code class="javascript">console.log(&#39;12&#39;+12);
</code></pre>
<p>例： 输出我今年age岁（”引引加加“）</p>
<pre><code class="javascript">console.log(&#39;我今年&#39; + age + &#39;岁&#39;)
</code></pre>
<p><em>变量不能写到字符串里面</em>，是通过和字符串相连的方式实现的</p>
<h6 id="（3）布尔型（Boolean型）：true或fasle；"><a href="#（3）布尔型（Boolean型）：true或fasle；" class="headerlink" title="（3）布尔型（Boolean型）：true或fasle；"></a>（3）布尔型（Boolean型）：true或fasle；</h6><pre><code class="javascript">let flag = true;
let flag1 = false;
</code></pre>
<p>ture &#x2F; false 参与加减法运算当 1 &#x2F; 0来看</p>
<h5 id="3-3-2-特殊数据类型："><a href="#3-3-2-特殊数据类型：" class="headerlink" title="3.3.2 特殊数据类型："></a>3.3.2 特殊数据类型：</h5><h6 id="（1）空值（null型）；"><a href="#（1）空值（null型）；" class="headerlink" title="（1）空值（null型）；"></a>（1）空值（null型）；</h6><pre><code class="javascript">    let space = null;
    console.log(space + &#39;pink&#39;); // nullpink
    console.log(space + 1); // 1		
</code></pre>
<h6 id="（2）未定义值（undefined型）；"><a href="#（2）未定义值（undefined型）；" class="headerlink" title="（2）未定义值（undefined型）；"></a>（2）未定义值（undefined型）；</h6><pre><code class="javascript">    let str;
    console.log(str);
    let variable = undefined;
    console.log(variable + &#39;pink&#39;); // undefinedpink
    
    console.log(variable + 1); // NaN  undefined 和数字相加 最后的结果是 NaN
</code></pre>
<h6 id="（3）转义字符；"><a href="#（3）转义字符；" class="headerlink" title="（3）转义字符；"></a>（3）转义字符；</h6><blockquote>
<p> \n 换行 ； \b 空格 ；杠’ 和杠” ; \b 空格；</p>
</blockquote>
<h5 id="3-3-3-获取变量数据类型-typeof-变量名"><a href="#3-3-3-获取变量数据类型-typeof-变量名" class="headerlink" title="3.3.3 获取变量数据类型 typeof 变量名"></a>3.3.3 获取变量数据类型 <em>typeof 变量名</em></h5><pre><code class="javascript">let num = 10;
console.log(typeof num);//number
</code></pre>
<h5 id="3-3-4-数据类型转换"><a href="#3-3-4-数据类型转换" class="headerlink" title="3.3.4 数据类型转换"></a>3.3.4 数据类型转换</h5><ul>
<li><h6 id="转换成字符型"><a href="#转换成字符型" class="headerlink" title="转换成字符型"></a>转换成字符型</h6><ol>
<li><p>利用  <em>变量.toString()</em></p>
<pre><code class="javascript">let num = 10;
let str =num.toString();
console.log(str);
console.log(typeof str);
</code></pre>
</li>
<li><p>利用  <em>String(变量)</em></p>
<p><code>console.log(String(num));</code></p>
</li>
<li><p>！！利用 <em>+ 拼接字符串的方法实现转换效果</em> &#x3D;&#x3D;隐式转换&#x3D;&#x3D;</p>
<pre><code class="javascript">let str1 =&#39; &#39;+num;
console.log(str1);
console.log(typeof str1);
</code></pre>
</li>
</ol>
</li>
<li><h6 id="转换成数字型"><a href="#转换成数字型" class="headerlink" title="转换成数字型"></a>转换成数字型</h6><ol>
<li><p>将string类型转换成整型  &#x3D;&#x3D;parseInt(变量)&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(parseInt(&#39;24.75&#39;));//3 取整

console.log(parseInt(&#39;120px&#39;));//120 会自动去掉非整型部分

console.log(parseInt(&#39;rem120px&#39;));//NaN 读到第一个字符非数字型就不继续读了
</code></pre>
</li>
<li><p>将string类型转换成浮点型  <strong>parseFloat(变量)</strong></p>
<blockquote>
<p>语法同parselnt</p>
</blockquote>
</li>
<li><p>利用 <strong>Number(变量)</strong></p>
<pre><code class="javascript">let str2 = &#39;123&#39;

console.log(Number(str2));

console.log(Number(&#39;152&#39;));
</code></pre>
</li>
<li><p>利用了算术运算 <strong>- * &#x2F;</strong> 隐式转换</p>
<pre><code class="javascript">console.log(&#39;12&#39; - 0);//12

console.log(&#39;123&#39; - &#39;120&#39;);//3
</code></pre>
</li>
</ol>
</li>
<li><h6 id="转换为布尔型-Boolean-函数"><a href="#转换为布尔型-Boolean-函数" class="headerlink" title="转换为布尔型 Boolean(函数)"></a>转换为布尔型 <em>Boolean(函数)</em></h6><p>“ “ ”、“0”、“NaN”、“underfined”、“null”转换后值为false，其余都为true</p>
<pre><code class="javascript">console.log(Boolean(null));//false
console.log(Boolean(&#39;我很好&#39;));//ture
</code></pre>
</li>
</ul>
<h3 id="3-4-运算符"><a href="#3-4-运算符" class="headerlink" title="3.4 运算符"></a>3.4 运算符</h3><blockquote>
<p> 也叫操作符</p>
</blockquote>
<p>JavaScript的运算符按运算符类型可以分为以下5种：</p>
<h5 id="（1）算术运算符"><a href="#（1）算术运算符" class="headerlink" title="（1）算术运算符"></a>（1）算术运算符</h5><p>​     “+”-“*”&#x2F;“</p>
<ul>
<li>浮点数在算数运算中会有误差，不能判断浮点数是否相等</li>
</ul>
<ul>
<li><p>表达式和返回值</p>
<ul>
<li>表达式是由数字、运算符、变量等组成的式子  1+1</li>
</ul>
</li>
</ul>
<h5 id="（2）递增和递减运算符"><a href="#（2）递增和递减运算符" class="headerlink" title="（2）递增和递减运算符"></a>（2）递增和递减运算符</h5><ul>
<li><p>a. 前置递增（++num）</p>
</li>
<li><p>b.后置递增（num++）&#x3D;&#x3D;先返回原值，再自加&#x3D;&#x3D;</p>
</li>
<li><p>例题：</p>
</li>
</ul>
<pre><code class="javascript">let a = 10;
++a;
let b = ++a + 2;
console.log(b); // 14

let c = 10;
c++;
letlet d = c++ + 2; 
console.log(d); // 13

let e = 10;
let f = e++ + ++e;
console.log(f); // 22
</code></pre>
<h5 id="（3）比较运算符；"><a href="#（3）比较运算符；" class="headerlink" title="（3）比较运算符；"></a>（3）比较运算符；</h5><ul>
<li>是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（ture &#x2F; false）作为比较运算的结果。</li>
</ul>
<img src="E:\sheep\study\notes\images\compare.jpg" alt="compare" style="zoom:80%;" />

<h5 id="（4）逻辑运算符；"><a href="#（4）逻辑运算符；" class="headerlink" title="（4）逻辑运算符；"></a>（4）逻辑运算符；</h5><blockquote>
<p>逻辑与  &amp;&amp;  、逻辑或 || 、逻辑非 ！</p>
<p>用来进行布尔值运算的运算符，其返回值也是布尔值。后面开发中经常用于多个条件的判断</p>
</blockquote>
<ul>
<li><h6 id="短路运算（逻辑中断）"><a href="#短路运算（逻辑中断）" class="headerlink" title="短路运算（逻辑中断）"></a><em><strong>短路运算（逻辑中断）</strong></em></h6><p>原理：当有多个表达式（值）时，左边的表达式可以确定结果时，就不再继续运算右边表达式的值；</p>
<ol>
<li>逻辑<strong>与</strong>（&#x3D;&#x3D;从左往右数有错误的就<strong>输出错误</strong>的，全对就输出最后一个&#x3D;&#x3D;）<ul>
<li>语法：<strong>表达式1 &amp;&amp; 表达式2</strong></li>
<li>若表达式1为真，则返回表达式2</li>
<li>若表达式1为假，则返回表达式1</li>
</ul>
</li>
</ol>
<p>​         例：<code>console.log(123 &amp;&amp; 456);// 456</code></p>
<p>​                 <code>console.log(0 &amp;&amp; 456);// 0</code></p>
<ol start="2">
<li><p>逻辑<strong>或</strong>（&#x3D;&#x3D;从左往右数有正确的就<strong>输出正确</strong>的，全错就输出最后一个&#x3D;&#x3D;）</p>
<ul>
<li>语法：<strong>表达式1 ||  表达式2</strong></li>
<li>若表达式1为真，则返回表达式1</li>
<li>若表达式1为假，则返回表达式2</li>
</ul>
<p>例：<code>console.log(123 || 456);// 123</code></p>
<p>​        <code>console.log(0 || 456);// 456</code></p>
<p>​		<code>console.log(123 || 456 ||789);// 789</code></p>
<pre><code class="javascript">// 经例：
    let num = 0;
    console.log(123 || num++);
    //程序读到123为真后逻辑中断返回123，num++不执行，此时num为0
    console.log(num);// 0
</code></pre>
</li>
</ol>
</li>
</ul>
<h5 id="（5）赋值运算符"><a href="#（5）赋值运算符" class="headerlink" title="（5）赋值运算符"></a>（5）赋值运算符</h5><blockquote>
<p>用来把数据赋值给变量的运算符</p>
</blockquote>
<img src="E:\sheep\study\notes\images\assignment.png" alt="assignment" style="zoom:80%;" />

<ul>
<li>自加 (自减、乘、除同理)</li>
</ul>
<pre><code class="javascript">num = num + 1; // num++
num = num + 2;// num +=2
</code></pre>
<p>（6）运算符优先级</p>
<img src="E:\sheep\study\notes\images\priority.png" alt="priority" style="zoom:80%;" />

<p>​           熟练掌握优先级并计算以下案例：</p>
<img src="E:\sheep\study\notes\images\text1.png" alt="text1" style="zoom:80%;" />

<img src="E:\sheep\study\notes\images\text2.png" alt="text2" style="zoom:80%;" />

<h3 id="3-5-流程控制分支结构"><a href="#3-5-流程控制分支结构" class="headerlink" title="3.5 流程控制分支结构"></a>3.5 流程控制分支结构</h3><blockquote>
<p>流程控制就是来控制代码按照什么结构顺序来执行</p>
<p>&#x3D;&#x3D;顺序结构&#x2F;分支结构&#x2F;循环结构&#x3D;&#x3D;</p>
<img src="E:\sheep\study\notes\images\structure.png" alt="structure" style="zoom:80%;" />
</blockquote>
<h4 id="3-5-1-顺序流程控制"><a href="#3-5-1-顺序流程控制" class="headerlink" title="3.5.1 顺序流程控制"></a>3.5.1 顺序流程控制</h4><ul>
<li>按照代码先后顺序，依次执行</li>
</ul>
<h4 id="3-5-2-分支流程控制if语句"><a href="#3-5-2-分支流程控制if语句" class="headerlink" title="3.5.2 分支流程控制if语句"></a>3.5.2 分支流程控制if语句</h4><ul>
<li><p>分支结构</p>
<ul>
<li><p>从上到下的代码中，根据&#x3D;&#x3D;不同条件&#x3D;&#x3D;，执行不同路径代码（&#x3D;&#x3D;多选一&#x3D;&#x3D;），从而得到不同的结果。</p>
</li>
<li><p>提供了两种分支结构语句</p>
</li>
</ul>
</li>
</ul>
<h5 id="（1）if-语句"><a href="#（1）if-语句" class="headerlink" title="（1）if 语句"></a>（1）if 语句</h5><ul>
<li><p>双分支语句（&#x3D;&#x3D;if else&#x3D;&#x3D;语句）</p>
<ul>
<li><p>语法结构（2选1）</p>
<pre><code class="javascript">if （条件表达式）&#123;
 //执行语句1;
&#125; else &#123;
//执行语句2;
&#125;
</code></pre>
</li>
<li><p>执行思路：若 if 里的表达式结果为 ture ，则执行语句1，反之则执行语句2；( else 可以不写)</p>
</li>
</ul>
</li>
<li><p>多分支语句（ &#x3D;&#x3D;if else if&#x3D;&#x3D; 语句）</p>
<ul>
<li><p>语法结构（多选1）   </p>
<pre><code class="javascript">if（条件表达式1）&#123;
    //语句1;
&#125; else if（条件表达式2）&#123;
    //语句2;
&#125; else if（条件表达式3）&#123;
    //语句3;
&#125;else &#123;
    //最后的语句;
&#125;
</code></pre>
</li>
<li><p>执行思路：若条件表达式 1 的结果为 ture ，则执行语句1，否则继续往下判断直到找到结果为ture的表达式，若全不满足，则输出最后的语句。</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>补充：三元表达式</p>
<ul>
<li><p>由三元运算符组成的式子我们称为三元表达式</p>
</li>
<li><p>语法结构</p>
<ul>
<li>&#x3D;&#x3D;条件表达式 ？ 表达式1 ：表达式2&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>执行思路</p>
<ul>
<li><p>如果条件表达式结果为真，则返回表达式1的值；</p>
</li>
<li><p>如果条件表达式结果为假，则返回表达式2的值。</p>
<pre><code class="javascript">let num = 10;
let result = num &gt; 5 ? &#39;是的&#39; : &#39;不是的&#39;;// 是的
//等价于
if(num &gt; 5)&#123;
    result =&#39;是的&#39;;
&#125;else&#123;
    result =&#39;不是的&#39;；
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="（2）switch-语句"><a href="#（2）switch-语句" class="headerlink" title="（2）switch 语句"></a>（2）switch 语句</h5><blockquote>
<p>switch 语句也是多分支语句，它用于基于不同的条件来执行不同的代码。当&#x3D;&#x3D;要针对变量设置一系列的特定值的选项时&#x3D;&#x3D;，就可以使用switch。</p>
</blockquote>
<ul>
<li><p>语法结构</p>
<pre><code class="javascript">switch(表达式)&#123;
    case value1:// 值1
        执行语句1;
        break;
    case value2:// 值2
        执行语句2;
        break;
    ...
    ...
    ...
    default:
        执行最后的语句;
&#125;
</code></pre>
</li>
<li><p>执行思路：利用表达式的值 和 case 后面的选项值 相匹配，如果匹配上，就执行该case里面的语句；如果都没匹配上，那么执行 default里面的语句</p>
<ul>
<li><p>&#x3D;&#x3D;！！&#x3D;&#x3D;表达式的值和case的值相匹配的时候必须是&#x3D;&#x3D;全等&#x3D;&#x3D; 必须是&#x3D;&#x3D;值和数据类型都一致&#x3D;&#x3D;才可以</p>
</li>
<li><p>如果当前的case里面没有break 则不会退出switch 而是继续执行下一个case</p>
<h5 id="（3）switch-和-if-else-if-的区别"><a href="#（3）switch-和-if-else-if-的区别" class="headerlink" title="（3）switch 和 if else if 的区别"></a>（3）switch 和 if else if 的区别</h5></li>
</ul>
</li>
<li><p>一般情况下，可以相互转换</p>
</li>
<li><p>switch…case 通常处理case为比较&#x3D;&#x3D;确定值&#x3D;&#x3D;的情况，而 if..else..语句更加灵活，常用于&#x3D;&#x3D;判断范围&#x3D;&#x3D;（大于或等于某个范围）</p>
</li>
<li><p>switch进行条件判断后直接执行到程序的条件语句，效率更高。而 if..else 语句有几种条件，就得判断几次</p>
</li>
<li><p>分枝少时用 if..else..if ；分枝多用 switch..case</p>
</li>
</ul>
<h4 id="3-5-3-循环流程控制"><a href="#3-5-3-循环流程控制" class="headerlink" title="3.5.3 循环流程控制"></a>3.5.3 循环流程控制</h4><h5 id="（1）for循环"><a href="#（1）for循环" class="headerlink" title="（1）for循环"></a>（1）for循环</h5><ul>
<li><p>for重复执行某些代码，通常和计数有关</p>
</li>
<li><p>语法结构</p>
<pre><code class="javascript">for (初始化变量;条件表达式;操作表达式)&#123;
    //循环体
&#125;
</code></pre>
</li>
<li><p>初始化变量：就是用 var 声明的一个普通的变量，通常作为计数器使用</p>
</li>
<li><p>条件表达式：用来决定每一次循环是否继续执行，就是终止的条件</p>
</li>
<li><p>操作表达式：每次循环最后执行的代码 通常用于我们计数器变量进行更新（递增或者递减）</p>
</li>
<li><p>代码体验   重复打印100句 你好</p>
<pre><code class="javascript">for(var i = 1;i &lt;= 100;i++)&#123;
    alert(&#39;你好&#39;)
&#125;
</code></pre>
</li>
</ul>
<h5 id="（2）双重for循环"><a href="#（2）双重for循环" class="headerlink" title="（2）双重for循环"></a>（2）双重for循环</h5><ul>
<li><p>语法结构</p>
<pre><code class="javascript">for (外层的初始化变量;外层的条件表达式;外层的操作表达式)&#123;
    for(里层的初始化变量;里层的条件表达式;里层的操作表达式)&#123;
        //执行语句
    &#125;
&#125;
</code></pre>
</li>
<li><p>我们可以把里面的循环看作是外层循环的语句</p>
</li>
<li><p>&#x3D;&#x3D;外层每循环一次，里面的循环执行全部&#x3D;&#x3D;</p>
</li>
<li><p>代码验证</p>
<pre><code class="javascript">for (let i =1;i &lt;= 3;i++)&#123;
    console.log(&#39;这是外层循环第&#39;+ i +&#39;次&#39;);
    for(let j = 1;j &lt;= 3;j++)&#123;
        console.log(&#39;这是内层循环第&#39;+ i +&#39;次&#39;);
    &#125;                     
&#125;
</code></pre>
</li>
</ul>
<h5 id="（3）while循环"><a href="#（3）while循环" class="headerlink" title="（3）while循环"></a>（3）while循环</h5><ul>
<li><p>语法结构</p>
<pre><code class="javascript">while(条件表达式)&#123;
    //循环体
&#125;
</code></pre>
</li>
<li><p>执行思路：&#x3D;&#x3D;当条件表达式为ture，则执行循环体&#x3D;&#x3D;；否则，退出循环</p>
</li>
<li><p>代码验证</p>
<pre><code class="javascript">let num = 1;
while (num &lt;= 100)&#123;
    console.log(&#39;hello&#39;);
    num++;//防止死循环
&#125;
</code></pre>
</li>
<li><p>里面应该也有计数器，初始化变量</p>
</li>
<li><p>里面应该也有操作表达式，完成计数器的更新，防止死循环</p>
</li>
</ul>
<h5 id="（4）do-while循环"><a href="#（4）do-while循环" class="headerlink" title="（4）do while循环"></a>（4）do while循环</h5><ul>
<li><p>语法结构</p>
<pre><code class="javascript">do &#123;
    //循环体
&#125;while(条件表达式)
</code></pre>
</li>
<li><p>执行思路：跟while不同的地方在于 &#x3D;&#x3D;do while 先执行一次循环体，再判断条件&#x3D;&#x3D;，如果条件表达式结果为真，则继续执行循环体，否则退出循环。</p>
</li>
<li><p>do while 循环体&#x3D;&#x3D;至少执行一次&#x3D;&#x3D;。</p>
</li>
<li><p>代码验证</p>
<pre><code class="javascript">let i = 1;
do &#123;
    console.log(&#39;how are you&#39;);
    i++;
&#125;while(i &lt;= 100)
</code></pre>
</li>
</ul>
<h5 id="（5）循环小结"><a href="#（5）循环小结" class="headerlink" title="（5）循环小结"></a>（5）循环小结</h5><ul>
<li>如果是用来计数的、和数字相关的，三者使用基本相同，但是我们&#x3D;&#x3D;更喜欢用for&#x3D;&#x3D;</li>
<li>while 和 do…while 可以做更复杂的判断条件，比for循环灵活一些</li>
<li>while 和 do…while 执行顺序不一样，while 先判断后执行，do…while 先执行一次，再判断执行</li>
</ul>
<h5 id="（6）continue-关键字"><a href="#（6）continue-关键字" class="headerlink" title="（6）continue 关键字"></a>（6）continue 关键字</h5><blockquote>
<p>用于立即&#x3D;&#x3D;跳出本次循环&#x3D;&#x3D;，&#x3D;&#x3D;继续下一次循环&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>代码实现</p>
<pre><code class="javascript">for (let i = 1;i &lt;= 5;i++)&#123;
    if (i == 3)&#123;
      continue;
     &#125;
     console.log(&#39;我正在吃第&#39;+ i +&#39;个苹果&#39;) ;
&#125;
</code></pre>
</li>
</ul>
<h5 id="（7）break-关键字"><a href="#（7）break-关键字" class="headerlink" title="（7）break 关键字"></a>（7）break 关键字</h5><blockquote>
<p>用于&#x3D;&#x3D;立即跳出整个循环&#x3D;&#x3D;（循环结束）</p>
</blockquote>
<ul>
<li><p>代码实现</p>
<pre><code class="javascript">for (let i = 1;i &lt;= 5;i++)&#123;
    if (i == 3)&#123;
      break;
     &#125;
     console.log(&#39;我正在吃第&#39;+ i +&#39;个苹果&#39;) ;
&#125;
</code></pre>
</li>
</ul>
<h3 id="3-6-数组"><a href="#3-6-数组" class="headerlink" title="3.6 数组"></a>3.6 数组</h3><blockquote>
<p>数是指&#x3D;&#x3D;一组数据的集合&#x3D;&#x3D;，其中的每个数据被称作&#x3D;&#x3D;元素&#x3D;&#x3D;，在数组中&#x3D;&#x3D;可以存放任意类型的元素&#x3D;&#x3D;。数组是一种将&#x3D;&#x3D;一组数据存储在单个变量名下&#x3D;&#x3D;的优雅方式。</p>
</blockquote>
<h4 id="3-6-1-数组的创建方式"><a href="#3-6-1-数组的创建方式" class="headerlink" title="3.6.1 数组的创建方式"></a>3.6.1 数组的创建方式</h4><h5 id="（1）利用-new-创建数组"><a href="#（1）利用-new-创建数组" class="headerlink" title="（1）利用 new 创建数组"></a>（1）利用 new 创建数组</h5><pre><code class="javascript">let arr = new Array();//创建了一个空的数组
let arr1 = new Array(2);//这个 2 表示数组的长度为 2 ，里面有两个空的数组元素
let arr2 = new Array(2,3);//这样写表示 里面有两个数组元素 是 2 和 3
</code></pre>
<h5 id="（2）利用数组字面量创建数组"><a href="#（2）利用数组字面量创建数组" class="headerlink" title="（2）利用数组字面量创建数组"></a>（2）利用数组字面量创建数组</h5><pre><code class="javascript">let arr = [];//创建了一个空的数组
let arr1 = [1,2,&#39;pink&#39;,ture];//我们数组里面的数据一定用逗号分隔
</code></pre>
<h4 id="3-6-2-获取数组中的元素"><a href="#3-6-2-获取数组中的元素" class="headerlink" title="3.6.2 获取数组中的元素"></a>3.6.2 获取数组中的元素</h4><blockquote>
<p>数组的&#x3D;&#x3D;索引&#x3D;&#x3D;</p>
<p>索引（下标）：用来访问数组元素的序号（&#x3D;&#x3D;数组下标从0开始&#x3D;&#x3D;）</p>
</blockquote>
<ul>
<li><p>获取数组元素</p>
<ul>
<li><p>格式： &#x3D;&#x3D;数组名[索引号]&#x3D;&#x3D;</p>
<pre><code class="javascript">//定义数组
let arrStus = [1,2,3];
//获取数组中的第二个元素
alert(arrStus[2]);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-6-3-遍历数组"><a href="#3-6-3-遍历数组" class="headerlink" title="3.6.3 遍历数组"></a>3.6.3 遍历数组</h4><blockquote>
<p>&#x3D;&#x3D;遍历&#x3D;&#x3D;就是把数组中的&#x3D;&#x3D;每个元素&#x3D;&#x3D;从头到尾都访问一次(类似于我们每天早上学生的点名)</p>
</blockquote>
<pre><code class="javascript">let arr = [&#39;red&#39;,&#39;green&#39;,&#39;blue&#39;];
for (let i = 0;i &lt; arr.length;i++)&#123;
    console.log(arr[i]);
&#125;
//1.因为我们的数组索引号从 0 开始,所以 i 必须从 0 开始  i &lt; 3
//2.输出的时候 arr[i] i 计数器当索引号来用
//3.arr.length 动态监测数组元素的个数
</code></pre>
<h4 id="3-6-4-数组中新增的元素"><a href="#3-6-4-数组中新增的元素" class="headerlink" title="3.6.4 数组中新增的元素"></a>3.6.4 数组中新增的元素</h4><blockquote>
<p>通过修改length长度以及索引号增加数组元素</p>
</blockquote>
<h5 id="（1）通过修改-length-长度新增数组元素"><a href="#（1）通过修改-length-长度新增数组元素" class="headerlink" title="（1）通过修改 length 长度新增数组元素"></a>（1）通过修改 length 长度新增数组元素</h5><ul>
<li><p>可通过修改 length 长度来实现数组扩容的目的</p>
</li>
<li><p>length 属性是可读写的</p>
<pre><code class="javascript">let arr = [1,2,3,4,5];
arr.length = 7;
console.log(arr[6]);//undefined
console.log(arr[7]);//undefined
</code></pre>
</li>
</ul>
<h5 id="（2）修改索引号-追加数组元素"><a href="#（2）修改索引号-追加数组元素" class="headerlink" title="（2）修改索引号 追加数组元素"></a>（2）修改索引号 追加数组元素</h5><pre><code class="javascript">let arr1 = [1,2,3];
arr1[3] = &#39;pink&#39;;
console.log(arr1);
</code></pre>
<ul>
<li>不要直接给 数组名 赋值，否则里面的数组元素都会被覆盖</li>
</ul>
<h4 id="3-6-5-冒泡排序"><a href="#3-6-5-冒泡排序" class="headerlink" title="3.6.5 冒泡排序"></a>3.6.5 冒泡排序</h4><blockquote>
<p>冒泡排序：是一种算法，把一系列的数据&#x3D;&#x3D;按照一定的顺序&#x3D;&#x3D;进行排列显示（从小到大或从大到小）</p>
<p>原理：重复的走访要排列的数列，&#x3D;&#x3D;一次比较两个元素，如果他们的顺序错误就把他们交换过来&#x3D;&#x3D;。走访数列的工作是重复的进行直到没有再需要交换的元素，也就是该数列已经排序完成。</p>
</blockquote>
<pre><code class="javascript">let arr = [4,1,2,3,5];
for (let i = 0;i &lt;= arr.length - 1;i++)&#123;
    for (let j = 0;j &lt;= arr.length - i - 1;j++)&#123;
        if (arr[j] &gt; arr[j + 1])&#123;
            let temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j+1] = temp;
        &#125;
    &#125;
&#125;
console.log(arr);
</code></pre>
<h3 id="3-7-函数"><a href="#3-7-函数" class="headerlink" title="3.7 函数"></a>3.7 函数</h3><h4 id="3-7-1-函数的概念"><a href="#3-7-1-函数的概念" class="headerlink" title="3.7.1 函数的概念"></a>3.7.1 函数的概念</h4><ul>
<li>函数：就是封装了一段&#x3D;&#x3D;可被重复调用执行的代码块&#x3D;&#x3D;，通过此代码块可以实现大量代码的重复使用</li>
</ul>
<h4 id="3-7-2-函数的使用"><a href="#3-7-2-函数的使用" class="headerlink" title="3.7.2 函数的使用"></a>3.7.2 函数的使用</h4><ul>
<li><p>声明函数 （关键字 function）</p>
<pre><code class="javascript">    function 函数名()&#123;
        //函数体
    &#125;
</code></pre>
<blockquote>
<ol>
<li>函数是做某件事情，函数名一般是&#x3D;&#x3D;动词&#x3D;&#x3D;</li>
<li>函数&#x3D;&#x3D;不调用自己不执行&#x3D;&#x3D;</li>
</ol>
</blockquote>
</li>
<li><p>调用函数</p>
<pre><code class="javascript">    函数名();//调用函数的时候千万不要忘记加小括号
</code></pre>
</li>
</ul>
<h4 id="3-7-3-函数的封装"><a href="#3-7-3-函数的封装" class="headerlink" title="3.7.3 函数的封装"></a>3.7.3 函数的封装</h4><ul>
<li>把一个或多个功能通过&#x3D;&#x3D;函数的方式封装起来&#x3D;&#x3D;，对外只提供一个简单的函数接口</li>
</ul>
<h4 id="3-7-4-函数的参数"><a href="#3-7-4-函数的参数" class="headerlink" title="3.7.4 函数的参数"></a>3.7.4 函数的参数</h4><h5 id="（1）参数的作用："><a href="#（1）参数的作用：" class="headerlink" title="（1）参数的作用："></a>（1）参数的作用：</h5><p>在&#x3D;&#x3D;函数内部&#x3D;&#x3D;有些值不固定，我们可以通过参数在&#x3D;&#x3D;调用函数时传递&#x3D;&#x3D;不同的值进去</p>
<ul>
<li><p>函数的参数可以有，也可以没有，个数不限</p>
<pre><code class="javascript">function 函数名（形参1，形参2...）&#123;// 形参 形式上的参数
    //函数体
&#125;
函数名（实参1，实参2...）// 实参 实际上的参数
</code></pre>
</li>
</ul>
<h5 id="（2）函数形参和实参个数不匹配问题"><a href="#（2）函数形参和实参个数不匹配问题" class="headerlink" title="（2）函数形参和实参个数不匹配问题"></a>（2）函数形参和实参个数不匹配问题</h5><pre><code class="javascript">function getSum(num1,num2) &#123;
    console.log(num1 + num2);
&#125;
</code></pre>
<ul>
<li><p>如果实参和形参的个数一致，则正常输出结果</p>
<pre><code class="javascript">getSum(1,2);// 3
</code></pre>
</li>
<li><p>如果实参的个数多于形参的个数</p>
<pre><code class="javascript">getSum(1,2,3);// 3
</code></pre>
</li>
<li><p>如果实参的个数小于形参的个数</p>
<blockquote>
<p>&#x3D;&#x3D;形参可以看作是一个不用声明的变量&#x3D;&#x3D;，num2 是一个变量但是没有接受值 它的值就是undefined</p>
</blockquote>
<pre><code class="javascript">getSum(1);// NaN
</code></pre>
</li>
</ul>
<h4 id="3-7-5-函数的返回值"><a href="#3-7-5-函数的返回值" class="headerlink" title="3.7.5 函数的返回值"></a>3.7.5 函数的返回值</h4><blockquote>
<p>把输出语句写在函数内部是不合理的（比如console.log），这时候我们就需要返回值</p>
</blockquote>
<h5 id="（1）return-语句"><a href="#（1）return-语句" class="headerlink" title="（1）return 语句"></a>（1）return 语句</h5><blockquote>
<ol>
<li><p>我们函数只是实现某种功能，最终的结果需要&#x3D;&#x3D;返回给函数的调用者&#x3D;&#x3D; 函数名（），这是通过 &#x3D;&#x3D;return&#x3D;&#x3D; 来实现的</p>
</li>
<li><p>只要函数遇到 return，就把后面的结果返回给函数的调用者；相当于：函数名（） &#x3D; return 后面的结果</p>
</li>
<li><p>终止函数：&#x3D;&#x3D;return语句之后的代码不被执行&#x3D;&#x3D;</p>
</li>
<li><p>return &#x3D;&#x3D;只会返回一个结果&#x3D;&#x3D;（最后一个），若要返回多个结果，可用&#x3D;&#x3D;数组&#x3D;&#x3D;来实现</p>
<p><code>return [num1+num2,num1-num2,num1*num2,num1/num2]</code></p>
</li>
</ol>
</blockquote>
<ul>
<li><p>格式</p>
<pre><code class="javascript">function 函数名() &#123;
    return 需要返回的结果;
&#125;
函数名();
console.log(函数名());
</code></pre>
</li>
<li><p>代码实操</p>
<pre><code class="javascript">//求任意两个数的和
function getSum(num1,num2)&#123;
    return num1 + num2;
&#125;
console.log(getSum(1,2));
</code></pre>
</li>
</ul>
<h5 id="（2）函数的返回值注意事项"><a href="#（2）函数的返回值注意事项" class="headerlink" title="（2）函数的返回值注意事项"></a>（2）函数的返回值注意事项</h5><ul>
<li><p>函数如果有 return 则返回的是 return 后面的值；如果&#x3D;&#x3D;没有 return 则返回 undefined&#x3D;&#x3D;</p>
<pre><code class="javascript">function fun1()&#123;
    return 666;
&#125;
console.log(fun1());// 返回 666
------------
function fun2()&#123;

&#125;
console.log(fun2());// 返回 undefined
</code></pre>
</li>
</ul>
<h5 id="（3）break-，cntinue-，return的区别"><a href="#（3）break-，cntinue-，return的区别" class="headerlink" title="（3）break ，cntinue ，return的区别"></a>（3）break ，cntinue ，return的区别</h5><ul>
<li>break：结束当前循环体</li>
<li>continue：跳出本次循环，继续执行下次循环</li>
<li>return：不仅可以退出循环，还能返回 return 语句中的值，同时还可以结束当前循环体内的代码</li>
</ul>
<h4 id="3-7-6-arguments-的使用"><a href="#3-7-6-arguments-的使用" class="headerlink" title="3.7.6 arguments 的使用"></a>3.7.6 arguments 的使用</h4><ul>
<li><p>在JS中，arguments 实际上是当前函数的一个&#x3D;&#x3D;内置对象&#x3D;&#x3D;，arguments 对象中&#x3D;&#x3D;存储了传递的所有实参&#x3D;&#x3D;。</p>
<ul>
<li>当我们不确定有多少个参数传递的时候，可以用 &#x3D;&#x3D;arguments&#x3D;&#x3D; 来获取。</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;arguments 展示形式是一个伪数组&#x3D;&#x3D;，因此&#x3D;&#x3D;可以进行遍历&#x3D;&#x3D;。伪数组的特点：</p>
<ul>
<li>具有 length 属性</li>
<li>按索引方式储存数据</li>
<li>不具有数组的push，pop等方法</li>
</ul>
</li>
<li><p>代码实操</p>
<pre><code class="javascript">//翻转数组
function reverse()&#123;
    let newArr = [];
    for (let i = arguments.length - 1;i &gt;= 0; i--)&#123;
        newArr[newArr.length] = arguments[i]
    &#125;
    return newArr
&#125;
let res = reverse(&#39;red&#39;,&#39;yellow&#39;,&#39;green&#39;,&#39;blue&#39;);
console.log(res);
</code></pre>
</li>
</ul>
<h4 id="3-7-8-函数是可以相互调用的"><a href="#3-7-8-函数是可以相互调用的" class="headerlink" title="3.7.8 函数是可以相互调用的"></a>3.7.8 函数是可以相互调用的</h4><pre><code class="javascript">function fn1()&#123;
    console.log(11);
    fn(2);//在 fn1 函数里面调用了 fn2 函数
&#125;
fn1();

function fn2()&#123;
    console.log(22);
&#125;
</code></pre>
<h4 id="3-7-9-函数的两种声明方式"><a href="#3-7-9-函数的两种声明方式" class="headerlink" title="3.7.9 函数的两种声明方式"></a>3.7.9 函数的两种声明方式</h4><h5 id="（1）利用函数关键字（function）自定义函数（命名函数）"><a href="#（1）利用函数关键字（function）自定义函数（命名函数）" class="headerlink" title="（1）利用函数关键字（function）自定义函数（命名函数）"></a>（1）利用函数关键字（function）自定义函数（命名函数）</h5><pre><code class="javascript">function fn()&#123;

&#125;
fn();
</code></pre>
<h5 id="（2）函数表达式（匿名函数）"><a href="#（2）函数表达式（匿名函数）" class="headerlink" title="（2）函数表达式（匿名函数）"></a>（2）函数表达式（匿名函数）</h5><blockquote>
<ul>
<li>&#x3D;&#x3D;没有定义函数名，只有变量名&#x3D;&#x3D;</li>
<li>函数表达式声明方式跟声明变量差不多，只不过变量里面存的是值，而函数表达式里面存的是函数</li>
</ul>
</blockquote>
<pre><code class="javascript">let 变量名 = function()&#123;
    console.log(&#39;我是函数表达式&#39;)；
&#125;
变量名();
</code></pre>
<h3 id="3-8-JS预解析"><a href="#3-8-JS预解析" class="headerlink" title="3.8 JS预解析"></a>3.8 JS预解析</h3><ul>
<li>js 引擎运行 js 分为两步 ：预解析、代码执行</li>
<li>预解析分为 变量预解析（变量提升） 和函数与解析（函数提升）<ul>
<li>变量提升：就是把所有的变量提升到当前作用域的最前面，不提升赋值操作。</li>
<li>函数提升：就是把所有的&#x3D;&#x3D;函数声明提升到当前作用域的最前面&#x3D;&#x3D;，&#x3D;&#x3D;不调用函数&#x3D;&#x3D;。</li>
</ul>
</li>
<li>预解析 js 会把里面所有的 var 还有 function 提升到当前作用域的最前面</li>
<li>&#x3D;&#x3D;es6 中使用 let ，没有变量提升&#x3D;&#x3D;</li>
</ul>
<h3 id="3-9-对象（object）"><a href="#3-9-对象（object）" class="headerlink" title="3.9 对象（object）"></a>3.9 对象（object）</h3><h4 id="3-9-1-什么是对象"><a href="#3-9-1-什么是对象" class="headerlink" title="3.9.1 什么是对象"></a>3.9.1 什么是对象</h4><blockquote>
<p>在 JS 中，对象是一组&#x3D;&#x3D;无序的相关属性和方法的集合&#x3D;&#x3D;，所有的事物都是对象，例如字符串、数值、数组、函数等</p>
</blockquote>
<ul>
<li>对象是由&#x3D;&#x3D;属性&#x3D;&#x3D;和&#x3D;&#x3D;方法&#x3D;&#x3D;组成的<ul>
<li>属性：事物的&#x3D;&#x3D;特征&#x3D;&#x3D;，在对象中用&#x3D;&#x3D;属性&#x3D;&#x3D;来表示（常用名词）</li>
<li>方法：事物的&#x3D;&#x3D;行为&#x3D;&#x3D;，在对象中用&#x3D;&#x3D;方法&#x3D;&#x3D;来表示（常用动词）</li>
</ul>
</li>
</ul>
<h4 id="3-9-2-创建对象的三种方式："><a href="#3-9-2-创建对象的三种方式：" class="headerlink" title="3.9.2 创建对象的三种方式："></a>3.9.2 创建对象的三种方式：</h4><ul>
<li><p>利用&#x3D;&#x3D;字面量&#x3D;&#x3D;创建对象：就是花括号{}里包含了表达这个事物（对象）的属性和方法</p>
<ul>
<li><p>创建对象：</p>
<ul>
<li><p>里面的属性或者方法我们采取&#x3D;&#x3D;键值对&#x3D;&#x3D;的方式 &#x3D;&#x3D;属性名 ：属性值&#x3D;&#x3D;</p>
</li>
<li><p>多个属性方法或者方法中间用逗号隔开</p>
</li>
<li><p>方法冒号后面跟的是个匿名函数</p>
<pre><code class="javascript">let obj = &#123;
    uname:&#39;小羊&#39;,
    age:18,
    sex:&#39;男&#39;,
    sayHi:function()&#123;
        console.log(&#39;hi~&#39;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>使用对象</p>
<ul>
<li><p>调用对象的属性，我们采用 &#x3D;&#x3D;对象名.属性名&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(obj.uname);
</code></pre>
</li>
<li><p>调用属性还有另外一种方法 &#x3D;&#x3D;对象名[‘属性名’]&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(obj[&#39;age&#39;]);
</code></pre>
</li>
<li><p>调用对象方法的方法 &#x3D;&#x3D;对象名.方法名&#x3D;&#x3D; 千万别忘记小括号</p>
<pre><code class="javascript">obj.sayHi();
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li><p>利用 &#x3D;&#x3D;new Object&#x3D;&#x3D; 创建对象</p>
<ul>
<li><p>创建对象</p>
<ul>
<li><p>利用&#x3D;&#x3D;等号赋值&#x3D;&#x3D;的方法添加对象的属性和方法</p>
</li>
<li><p>每个属性和方法之间用&#x3D;&#x3D;分号&#x3D;&#x3D;结束</p>
<pre><code class="javascript">let obj = new Object;//创建了一个空的对象
obj.uname = &#39;小羊&#39;;
obj.age = 18;
obj.sex = &#39;男&#39;;
obj.sayHi = function() &#123;
    console.log(&#39;hi~&#39;)
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p>使用对象</p>
<ul>
<li>同自变量调用对象一样</li>
</ul>
</li>
</ul>
</li>
<li><p>利用&#x3D;&#x3D;构造函数&#x3D;&#x3D;创建对象</p>
<blockquote>
<p>为什么需要构造函数：前面两种方式一次只能创建一个对象</p>
<p>因此我们可以利用函数的方法，重复这些相同的代码，我们就把这个函数称为 构造函数</p>
<p>构造函数：就是&#x3D;&#x3D;把对象里一些相同的属性和方法抽象出来封装到函数里面&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li><p>构造函数的语法格式</p>
<ul>
<li>构造&#x3D;&#x3D;函数名首字母必须大写&#x3D;&#x3D;</li>
<li>构造函数不需要返回 return 就可以返回结果</li>
</ul>
<pre><code class="javascript">function Star(uname,age,sex) &#123;
    this.name = uname;
    this.age = age;
    this.sex = sex;
    this.sing = function()&#123;
        console.log()
    &#125;
&#125;
</code></pre>
</li>
<li><p>调用构造函数（必须使用new）</p>
</li>
</ul>
<pre><code class="javascript">let ldh = new Star(&#39;刘德华&#39;,18,&#39;男&#39;);
console.log(ldh.name);
console.log(ldg[&#39;age&#39;]);
ldh.sing(&#39;冰雨&#39;);
</code></pre>
</li>
<li><p>构造函数和对象</p>
<ul>
<li><p>&#x3D;&#x3D;我们利用构造函数创建对象的过程也称为对象的实例化&#x3D;&#x3D;</p>
</li>
<li><p>构造函数 &#x3D;&#x3D;类似于 java 语言里面的类&#x3D;&#x3D;（Star）</p>
<pre><code class="javascript">function Star(uname,age,sex) &#123;
    this.name = uname;
    this.age = age;
    this.sex = sex;
    this.sing = function()&#123;
        console.log()
    &#125;
&#125;
</code></pre>
</li>
<li><p>对象 是一个具体的事物 &#x3D;&#x3D;类似于类的实例化&#x3D;&#x3D;（ldh）：</p>
<pre><code class="javascript">let ldh = new Star(&#39;刘德华&#39;,18,&#39;男&#39;);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-9-3-变量、属性、函数、方法的区别"><a href="#3-9-3-变量、属性、函数、方法的区别" class="headerlink" title="3.9.3 变量、属性、函数、方法的区别"></a>3.9.3 变量、属性、函数、方法的区别</h4><ul>
<li><p>变量和属性</p>
<ul>
<li>相同点：都是用来存储数据的</li>
<li>不同点：<ul>
<li>变量是单独声明并赋值，使用时可以直接写变量名（单独存在）；</li>
<li>属性是在对象里面的，不需要声明，使用时必须是 &#x3D;&#x3D;对象.属性&#x3D;&#x3D;。</li>
</ul>
</li>
</ul>
</li>
<li><p>函数和方法</p>
<ul>
<li><p>相同点：都是用来实现某种功能的</p>
</li>
<li><p>不同点：</p>
<ul>
<li>函数是单独声明，并且调用的（单独存在）</li>
<li>方法是在对象里面的，调用的时候  &#x3D;&#x3D;对象.方法（）&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3-9-4-new-关键字执行过程"><a href="#3-9-4-new-关键字执行过程" class="headerlink" title="3.9.4 new 关键字执行过程"></a>3.9.4 new 关键字执行过程</h4><ul>
<li>new 构造函数首先在内存中创建一个空的对象</li>
<li>this 就会指向刚才创建的空对象</li>
<li>执行构造函数里面的代码，给空对象添加属性和方法</li>
<li>返回这个对象（所以不需要return）</li>
</ul>
<h4 id="3-9-5-遍历对象"><a href="#3-9-5-遍历对象" class="headerlink" title="3.9.5 遍历对象"></a>3.9.5 遍历对象</h4><blockquote>
<p>对象里的属性和方法是无序的，所以不能使用 for 循环遍历</p>
<p>&#x3D;&#x3D;for…in&#x3D;&#x3D; 语句用于对数组或者对象的属性进行循环操作。</p>
</blockquote>
<ul>
<li><p>语法格式</p>
<pre><code class="javascript">for (变量 in 对象) &#123;

&#125;
</code></pre>
<ul>
<li><p>代码实操</p>
</li>
<li><p>我们使用 for…in 里面的变量，一般写 &#x3D;&#x3D;k&#x3D;&#x3D; 或者 &#x3D;&#x3D;key&#x3D;&#x3D;</p>
<pre><code class="javascript">let obj = &#123;
    name : &#39;sheep&#39;,
    age : 18,
    sex : &#39;女&#39;,
    fn : function()&#123;&#125;
&#125;

//遍历对象
for (let k in obj) &#123;
    console.log(k);// k 变量 输出得到属性名
    console.log(obj[k]);// obj[k] 输出得到属性值
&#125;
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="3-10-内置对象"><a href="#3-10-内置对象" class="headerlink" title="3.10 内置对象"></a>3.10 内置对象</h3><ul>
<li>JS中对象分为三种：自定义对象、内置对象、浏览器对象</li>
<li>&#x3D;&#x3D;内置对象&#x3D;&#x3D;就是指 JS 语言自带的一些对象，供开发者使用，并提供了一些常用的或者是最基本而必要的功能（属性和方法），帮助我们&#x3D;&#x3D;快速开发&#x3D;&#x3D;</li>
<li>JS 提供了多个内置对象：Math、Date、Array、String等</li>
</ul>
<h4 id="3-10-1-查阅文档"><a href="#3-10-1-查阅文档" class="headerlink" title="3.10.1 查阅文档"></a>3.10.1 查阅文档</h4><ul>
<li><p>MDN</p>
<p><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/">https://developer.mozilla.org/zh-CN/</a></p>
</li>
</ul>
<h4 id="3-10-2-Math"><a href="#3-10-2-Math" class="headerlink" title="3.10.2 Math"></a>3.10.2 Math</h4><img src="E:\sheep\study\notes\images\Math对象.png" alt="Math对象" style="zoom:80%;" />

<ul>
<li><p>不是构造函数，所以我们不需要 new 来调用，而是&#x3D;&#x3D;直接使用&#x3D;&#x3D;里面的属性和方法即可</p>
<ul>
<li><p>调用属性</p>
<pre><code class="javascript">//圆周率
console.log(Math.PI);
</code></pre>
</li>
<li><p>调用方法</p>
<pre><code class="javascript">//取最大值
console.log(Math.max(1,99,3))
</code></pre>
</li>
</ul>
</li>
<li><p>随机数方法 Math.random</p>
<ul>
<li><p>random() 返回一个[ 0,1 )之间随机的小数</p>
</li>
<li><p>这个方法里面不跟参数</p>
</li>
<li><p>我们想要得到这两个数之间的随机整数 并且 包含这两个整数</p>
<pre><code class="javascript">function getRandom(min, max) &#123;
      min = Math.ceil(min);
      max = Math.floor(max);
      return Math.floor(Math.random() * (max - min + 1)) + min; //含最大值，含最小值
&#125;
    console.log(getRandom(1,10));
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-10-3-Date-日期对象"><a href="#3-10-3-Date-日期对象" class="headerlink" title="3.10.3 Date 日期对象"></a>3.10.3 Date 日期对象</h4><ul>
<li><p>Date 是一个&#x3D;&#x3D;构造函数&#x3D;&#x3D;，必须使用 new 来调用创建我们的日期对象(&#x3D;&#x3D;必须实例化&#x3D;&#x3D;)</p>
<pre><code class="javascript">let date = new Date();
console.log(date);
</code></pre>
</li>
<li><p>如果没有参数，则返回当前系统的当前时间</p>
</li>
</ul>
<blockquote>
<p>参数常用的写法</p>
<ul>
<li><p>数字型 2019,10,1</p>
<pre><code class="javascript">let date1 = new Date(2019,10,1);
console.log(date1);
</code></pre>
</li>
<li><p>字符串型 ‘2019-10-1 8:8:8’</p>
<pre><code class="javascript">let date2 = new Date( &#39;2019-10-1 8:8:8&#39;);
console.log(date2);
</code></pre>
</li>
</ul>
</blockquote>
<ul>
<li><p>日期格式化</p>
<img src="E:\sheep\study\notes\images\Date对象.png" alt="Date对象" style="zoom:80%;" />
</li>
<li><p>代码实操</p>
<pre><code class="javascript">let date = new Date();//实例化
console.log(date.getFullYear());//返回当前日期的年
console.log(date.getMonth() + 1);//返回月份 month（0 - 11）;
console.log(date.getDay() + 1);//返回星期几 （周六返回6；周日返回0）
</code></pre>
</li>
<li><p>获取Date的总的毫秒数（时间戳）（&#x3D;&#x3D;距离1970.01.01&#x3D;&#x3D;过了多少毫秒数）</p>
<ul>
<li><p>通过  valueOf()</p>
<pre><code class="javascript">let date = new Date();
console.log(date.valueOf());
</code></pre>
</li>
<li><p>通过  getTime()</p>
<pre><code class="javascript">let date = new Date();
console.log(date.getTime());
</code></pre>
</li>
<li><p>简单写法   &#x3D;&#x3D;+&#x3D;&#x3D;new Date()</p>
<pre><code class="javascript">let date1 = +new Date();
</code></pre>
</li>
<li><p>h5 新增写法</p>
<pre><code class="javascript">console.log(Date.now());
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-10-4-数组对象"><a href="#3-10-4-数组对象" class="headerlink" title="3.10.4 数组对象"></a>3.10.4 数组对象</h4><h5 id="（1）检测是否为数组"><a href="#（1）检测是否为数组" class="headerlink" title="（1）检测是否为数组"></a>（1）检测是否为数组</h5><ul>
<li><p>&#x3D;&#x3D;instanceof&#x3D;&#x3D; 运算符,可以用来检测是否为数组</p>
<pre><code class="javascript">let arr = [];
let obj = &#123;&#125;;
console.log(arr instanceof Array);//true
console.log(obj instanceof Array);//false
</code></pre>
</li>
<li><p>&#x3D;&#x3D;Array.isArray(参数)&#x3D;&#x3D;;  h5新增</p>
<pre><code class="javascript">let arr = [];
console.log(Array.isArray(arr));//true
</code></pre>
</li>
</ul>
<h5 id="（2）添加删除数组元素的方法"><a href="#（2）添加删除数组元素的方法" class="headerlink" title="（2）添加删除数组元素的方法"></a>（2）添加删除数组元素的方法</h5><img src="E:\sheep\study\notes\images\添、删数组元素的方法.png" alt="添、删数组元素的方法" style="zoom:150%;" />

<ul>
<li><p>&#x3D;&#x3D;push()&#x3D;&#x3D;  在数组的&#x3D;&#x3D;末尾&#x3D;&#x3D;，添加一个或多个数组元素</p>
<ul>
<li><p>push()  括号里参数直接写数组元素</p>
</li>
<li><p>&#x3D;&#x3D;push 完之后，返回的结果是新数组的长度&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr.push(4,&#39;pink&#39;);
console.log(arr.push(4,&#39;pink&#39;))// 5
</code></pre>
</li>
</ul>
</li>
<li><p>unshift()  在数组的&#x3D;&#x3D;开头&#x3D;&#x3D;，添加一个或多个数组元素</p>
<ul>
<li><p>unshift()  括号里参数直接写数组元素</p>
</li>
<li><p>&#x3D;&#x3D;unshift 完之后，返回的结果是新数组的长度&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [1,2,3];
arr.unshift(4,&#39;pink&#39;);
console.log(arr.unshift(4,&#39;pink&#39;))// 5
</code></pre>
</li>
</ul>
</li>
<li><p>pop()  删除数组的最后一个元素</p>
<ul>
<li><p>pop()  里不写参数</p>
</li>
<li><p>&#x3D;&#x3D;返回值是被删掉的数组元素&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [1,2,3];
arr.pop();
console.log(arr.pop());// 3
</code></pre>
</li>
</ul>
</li>
<li><p>shift()  删除数组的第一个元素</p>
<ul>
<li><p>shift()  里不写参数</p>
</li>
<li><p>&#x3D;&#x3D;返回值是被删掉的数组元素&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [1,2,3];
arr.shift();
console.log(arr.shift());// 1
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（3）数组排序"><a href="#（3）数组排序" class="headerlink" title="（3）数组排序"></a>（3）数组排序</h5><ul>
<li><p>翻转数组</p>
<ul>
<li><p>&#x3D;&#x3D;reverse()&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [&#39;pink&#39;,&#39;red&#39;,&#39;blue&#39;];
arr.reverse();
console.log(arr);
</code></pre>
</li>
</ul>
</li>
<li><p>冒泡排序</p>
<ul>
<li><p>&#x3D;&#x3D;sort()&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [8,3,6,4,5];
arr.sort(function(a - b)&#123;
    return a - b;//升序的顺序排列
    return b - a;//降序的顺序排列
&#125;);
console.log(arr1);
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（4）数组索引方法"><a href="#（4）数组索引方法" class="headerlink" title="（4）数组索引方法"></a>（4）数组索引方法</h5><p><img src="E:\sheep\study\notes\images\数组索引方法.png" alt="数组索引方法"></p>
<ul>
<li><p>&#x3D;&#x3D;indexOf(数组元素,[起始位置])&#x3D;&#x3D;</p>
<ul>
<li><p>只返回第一个满足条件的数组元素的索引号</p>
</li>
<li><p>如果在该数组里找不到元素，则返回 -1</p>
<pre><code class="javascript">let arr = [&#39;pink&#39;,&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;blue&#39;];
console.log(arr.indexOf(&#39;blue&#39;));// 2 返回数组元素的索引号
</code></pre>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;lastIndexOf(数组元素)&#x3D;&#x3D;</p>
<ul>
<li><p>类似于 indexOf()，不过 lastIndexOf()是从后往前查找</p>
</li>
<li><p>&#x3D;&#x3D;如果在该数组里找不到元素，则返回 -1&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [&#39;pink&#39;,&#39;red&#39;,&#39;blue&#39;,&#39;green&#39;,&#39;blue&#39;];
console.log(arr.lastIndexOf(&#39;blue&#39;));// 4
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（5）数组转换为字符串"><a href="#（5）数组转换为字符串" class="headerlink" title="（5）数组转换为字符串"></a>（5）数组转换为字符串</h5><ul>
<li><p>toString() </p>
<ul>
<li><p>直接转换为字符串</p>
<pre><code class="javascript">let arr = [1,2,3];
console.log(arr.toString());//1,2,3
</code></pre>
</li>
</ul>
</li>
<li><p>join(‘分隔符’)</p>
<ul>
<li><p>更高级，join() 可以&#x3D;&#x3D;自定义分隔符&#x3D;&#x3D;</p>
<pre><code class="javascript">let arr = [1,2,3];
console.log(arr.join());// 1,2,3
console.log(arr.join(&#39;-&#39;));//1-2-3
console.log(arr.join(&#39;&amp;&#39;));//1&amp;2&amp;3
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-10-5-字符串对象"><a href="#3-10-5-字符串对象" class="headerlink" title="3.10.5 字符串对象"></a>3.10.5 字符串对象</h4><h5 id="（1）基本包装类型"><a href="#（1）基本包装类型" class="headerlink" title="（1）基本包装类型"></a>（1）基本包装类型</h5><blockquote>
<p>复杂数据类型才有 属性和方法</p>
<p>简单数据类型为什么会有 length 属性呢</p>
</blockquote>
<ul>
<li><p>基本包装类型：就是&#x3D;&#x3D;把简单数据类型&#x3D;&#x3D;（三个：String、Number、Boolean）&#x3D;&#x3D;包装成为了复杂数据类型&#x3D;&#x3D;,这样&#x3D;&#x3D;基本数据类型就有了属性和方法&#x3D;&#x3D;</p>
<pre><code class="javascript">// 底层流程展示
let str = &#39;sheep&#39;;
console.log(str.length);
//1. 把简单数据类型包装为复杂数据类型
let temp = new String(&#39;andy&#39;);
//2. 把临时变量的值给 str
str = temp;
//3. 销毁这个临时变量
temp = null;
</code></pre>
</li>
</ul>
<h5 id="（2）字符串的不可变性"><a href="#（2）字符串的不可变性" class="headerlink" title="（2）字符串的不可变性"></a>（2）字符串的不可变性</h5><ul>
<li>&#x3D;&#x3D;值不可变&#x3D;&#x3D;：看上去是改变了内容，实际上是&#x3D;&#x3D;改变字符串变量名指向的地址&#x3D;&#x3D;（好像指针噢），内存中开辟了一个新的内存空间存了一个新值（因此&#x3D;&#x3D;不要大量的拼接字符串&#x3D;&#x3D;）</li>
</ul>
<h5 id="（3）根据字符返回位置"><a href="#（3）根据字符返回位置" class="headerlink" title="（3）根据字符返回位置"></a>（3）根据字符返回位置</h5><blockquote>
<p>字符串的所有方法，都不会修改字符串本身（字符串本身是不可变的），操作完成会返回一个新的字符串</p>
</blockquote>
<ul>
<li><p>&#x3D;&#x3D;indexOf(‘字符’,[起始位置])&#x3D;&#x3D;</p>
<pre><code class="javascript">let str = &#39;改革春风吹满地，春天来了&#39;；
console.log(str.indexOf(&#39;春&#39;));// 2
console.log(str.indexOf(&#39;春&#39;,3));// 8 从索引号是 3 的位置开始往后查找
</code></pre>
</li>
<li><p>&#x3D;&#x3D;lastIndexOf(‘字符’,[起始位置])&#x3D;&#x3D;</p>
</li>
</ul>
<h5 id="（4）根据位置返回字符（重点）"><a href="#（4）根据位置返回字符（重点）" class="headerlink" title="（4）根据位置返回字符（重点）"></a>（4）根据位置返回字符（重点）</h5><ul>
<li><p><strong>charAt(index)</strong></p>
<ul>
<li><p>&#x3D;&#x3D;获取指定位置处的字符&#x3D;&#x3D;</p>
<pre><code class="javascript">let str = &#39;sheep&#39;;
console.log(str.charAt(1));// h
</code></pre>
</li>
<li><p>利用 charAt( ) 遍历字符串</p>
<pre><code class="javascript">for (i = 0; i &lt; str.lenghth ;i++) &#123;
    console.log(str.charAt(i));
&#125;
</code></pre>
</li>
</ul>
</li>
<li><p><strong>charCodeAt(index)</strong>  </p>
<ul>
<li><p>&#x3D;&#x3D;返回相应索引号的字符ASCII值&#x3D;&#x3D;  目的：判断用户按下了哪个键</p>
<pre><code class="javascript">let str = &#39;sheep&#39;;
console.log(charCodeAt(1));// 104
</code></pre>
</li>
<li><p>附 ASCII 码表</p>
<p><img src="E:\sheep\study\notes\images\ASCII码表.PNG" alt="ASCII码表"></p>
</li>
</ul>
</li>
<li><p>&#x3D;&#x3D;<strong>str[index]</strong>&#x3D;&#x3D;</p>
<ul>
<li>&#x3D;&#x3D;获取指定位置处的字符&#x3D;&#x3D;（HTML5）</li>
</ul>
<pre><code class="javascript">let str = &#39;sheep&#39;;
console.log(str[1]);// h
</code></pre>
</li>
</ul>
<h5 id="（5）字符串的基本操作方法（重点）"><a href="#（5）字符串的基本操作方法（重点）" class="headerlink" title="（5）字符串的基本操作方法（重点）"></a>（5）字符串的基本操作方法（重点）</h5><p><img src="E:\sheep\study\notes\images\字符串操作方法.png" alt="字符串操作方法"></p>
<h5 id="（6）字符串的连接"><a href="#（6）字符串的连接" class="headerlink" title="（6）字符串的连接"></a>（6）字符串的连接</h5><ul>
<li><p>concat(str1,str2…)</p>
<ul>
<li><p>用于连接两个或多个字符串，拼接字符串，等效于+ ，+更常用</p>
<pre><code class="javascript">let str = &#39;andy&#39;;
console.log(str.concat(&#39;red&#39;));// andyred
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（7）自定义位置索引"><a href="#（7）自定义位置索引" class="headerlink" title="（7）自定义位置索引"></a>（7）自定义位置索引</h5><ul>
<li><p>substr(start,length)</p>
<ul>
<li><p>从 start 位置开始索引，length 取的个数</p>
<pre><code class="javascript">let str = &#39;改革春风吹满地&#39;;
console.log(str.substr(2,2));// 春风
</code></pre>
</li>
</ul>
</li>
<li><p>slice(start,end)</p>
<ul>
<li>从 start 位置开始，截取到 end 位置（不包含end）</li>
</ul>
</li>
<li><p>substring(start,end)</p>
<ul>
<li>从 start 位置开始，截取到 end 位置（不包含end），基本和 slice 相同，但不接受负值</li>
</ul>
</li>
</ul>
<h5 id="（8）替换字符"><a href="#（8）替换字符" class="headerlink" title="（8）替换字符"></a>（8）替换字符</h5><ul>
<li><p>replace(‘被替换的字符’,’替换为的字符’)</p>
<ul>
<li><p>只替换第一个符合要求的字符</p>
<pre><code class="javascript">let str = &#39;andy&#39;;
console.log(str.replace(&#39;a&#39;,&#39;b&#39;));
</code></pre>
</li>
</ul>
</li>
</ul>
<h5 id="（9）字符串转换为数组"><a href="#（9）字符串转换为数组" class="headerlink" title="（9）字符串转换为数组"></a>（9）字符串转换为数组</h5><ul>
<li><p>split(‘分隔符’)</p>
<ul>
<li><p>分隔符取决于字符串用什么符号来把它们分开的</p>
<pre><code class="javascript">let str1 = &#39;red,pink,blue&#39;;
console.log(str1.split(&#39;,&#39;));//[red,pink,blue]

let str2 = &#39;red&amp;pink&amp;blue&#39;;
console.log(str2.split(&#39;&amp;&#39;));//[red,pink,blue]
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="3-11-JS-简单数据类型和复杂数据类型"><a href="#3-11-JS-简单数据类型和复杂数据类型" class="headerlink" title="3.11 JS 简单数据类型和复杂数据类型"></a>3.11 JS 简单数据类型和复杂数据类型</h4><h5 id="3-11-1-简单类型与复杂类型"><a href="#3-11-1-简单类型与复杂类型" class="headerlink" title="3.11.1 简单类型与复杂类型"></a>3.11.1 简单类型与复杂类型</h5><ul>
<li><p>简单类型又叫做&#x3D;&#x3D;值类型&#x3D;&#x3D;，在存储时变量中存储的是值本身，因此叫做值类型</p>
<blockquote>
<p>string , number , boolean , undefined , null</p>
</blockquote>
<ul>
<li><p>其中 null 比较特殊 typeof 它返回的是一个空的对象（object）</p>
<blockquote>
<p>所以如果有一个变量我们以后打算存储为对象，暂时没想好放什么，这个时候就给 null</p>
</blockquote>
<pre><code class="javascript">let timer = null;
console.log(typeof timer);//object
</code></pre>
</li>
</ul>
</li>
<li><p>复杂类型又叫做&#x3D;&#x3D;引用类型&#x3D;&#x3D;，在存储时变量中存储的仅仅是地址（引用），因此叫做引用类型</p>
<blockquote>
<p>通过 new 关键字创建的对象（系统对象，自定义对象）：如Object , Array , Date 等</p>
</blockquote>
</li>
</ul>
<h5 id="3-11-2-堆和栈"><a href="#3-11-2-堆和栈" class="headerlink" title="3.11.2 堆和栈"></a>3.11.2 堆和栈</h5><blockquote>
<p>&#x3D;&#x3D;JS 里没有堆和栈的概念，只是帮助我们方便理解代码的执行方式&#x3D;&#x3D;</p>
</blockquote>
<ul>
<li>分配区别<ul>
<li>栈（操作系统）:由操作系统自动分配释放存放函数的参数值、局部变量的值等。其操作方式类似于数据结构中的栈;&#x3D;&#x3D;简单数据类型存放到栈里面&#x3D;&#x3D;</li>
<li>2、堆（操作系统）∶存储复杂类型(对象)，一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收。&#x3D;&#x3D;复杂数据类型存放到堆里面&#x3D;&#x3D;</li>
</ul>
</li>
</ul>
<h5 id="3-11-3-简单类型的内存分配"><a href="#3-11-3-简单类型的内存分配" class="headerlink" title="3.11.3 简单类型的内存分配"></a>3.11.3 简单类型的内存分配</h5><ul>
<li>简单数据类型存放到栈里面</li>
<li>在栈里面直接存放的是值</li>
</ul>
<h5 id="3-11-4-复杂类型的内存分配"><a href="#3-11-4-复杂类型的内存分配" class="headerlink" title="3.11.4 复杂类型的内存分配"></a>3.11.4 复杂类型的内存分配</h5><ul>
<li>复杂数据类型存放到堆里面<ul>
<li>首先在栈里面存放地址 用十六进制表示，然后这个地址指向堆里面存储的数据</li>
</ul>
</li>
</ul>
<h5 id="3-11-5-简单类型传参"><a href="#3-11-5-简单类型传参" class="headerlink" title="3.11.5 简单类型传参"></a>3.11.5 简单类型传参</h5><ul>
<li><p>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都&#x3D;&#x3D;不会影响到的外部变量&#x3D;&#x3D;。</p>
<pre><code class="javascript">function fn(a) &#123;
    a++;
    console.log(a);// 11
&#125;
let x = 10;
fn(x);
console.log(x);// 10
</code></pre>
</li>
</ul>
<h5 id="3-11-5-复杂类型传参"><a href="#3-11-5-复杂类型传参" class="headerlink" title="3.11.5 复杂类型传参"></a>3.11.5 复杂类型传参</h5><ul>
<li><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，&#x3D;&#x3D;形参和实参其实保存的是同一个堆地址,所以操作的是同一个对象&#x3D;&#x3D;。</p>
<pre><code class="javascript">function Person(name) &#123;
    this.name = name;
&#125;
function f1(x) &#123;
    console.log(x.name);// 2.这个输出是:刘德华
    x.name = &#39;张学友&#39;;
    console.log(x.name);// 3.这个输出是:张学友
&#125;
let p = new Person(&#39;刘德华&#39;);
console.log(p.name);// 1.这个输出是:刘德华
f1(p);
console.log(p.name);// 4.这个输出是:张学友
</code></pre>
</li>
<li><p>图解上面代码：</p>
<p><img src="E:\sheep\study\notes\images\复杂类型.png" alt="复杂类型"></p>
</li>
</ul>

  </div>
  <div id="gitalk-container"></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging">
    
    <a href="/2022/11/11/markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">
        <div class="post-paging-last">
            <span>上一篇</span>
            <p>markdown基本语句</p>
        </div>
    </a>
    

    
    <a href="/2022/11/11/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/">
        <div class="post-paging-next">
            <span>下一篇</span>
            <p>PC端网页特效</p>
        </div>
    </a>
    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2022 By sheep. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/79e/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?94ea92e08139a609b3e9a9fd82080c82";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"f9b10e7298e1a0d041ea","clientSecret":"ed9c807b5965710c6636de27d7972668257d348c","repo":"myblogtalk","owner":"sheep1005","admin":"sheep1005"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('true')){
            gitalk.render('gitalk-container')
        }
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>

