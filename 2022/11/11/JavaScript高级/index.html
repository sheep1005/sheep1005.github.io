<!DOCTYPE html>
<html>
	<head>
		
<title>JavaScript高级-hi</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="shortcut icon" type="image/x-icon" href="/image/favicon.ico">

<link rel="stylesheet" href="/css/index.css">



<meta name="keywords" content="前端,学习笔记,JavaScript,">
<meta name="description" content="也不过如此嘛">


<script src="/js/jquery.min.js"></script>


<script src="/js/index.js"></script>


<script src="/js/fancybox.umd.js"></script>


<script src="/js/fancybox-images.js"></script>


<script src="/js/gitalk.min.js"></script>


<script src="/js/hljs.min.js"></script>
 
<script>hljs.highlightAll();</script>

	<meta name="generator" content="Hexo 6.3.0"></head>

	<body>
		
	<div class="header">
		<div class="header-top" id="header-top">
			<div class="h-left">
				<a href="/">
					<img src="/image/logo.png" alt="Quiet">
				</a>
			</div>
			<div class="h-right">
				<ul>
					
						
								<li>
									<a href="/">
										HOME
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/archives">
										ARCHIVE
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/categories">
										CATEGORIES
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/tags">
										TAGS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/links">
										LINKS
									</a>
									<span class="dot"></span>
								</li>
								
									
						
								<li>
									<a href="/about">
										ABOUT
									</a>
									<span class="dot"></span>
								</li>
								
									
				</ul>
			</div>
			<div class="h-right-close">
				<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24" height="24">
					<path fill="none" d="M0 0h24v24H0z" />
					<path d="M3 4h18v2H3V4zm0 7h18v2H3v-2zm0 7h18v2H3v-2z" fill="rgba(68,68,68,1)" />
				</svg>
			</div>
		</div>
	</div>
	<div class="sidebar">
    <div class="topo">
        <h2>sheep</h2>
    </div>
    <ul>
        
        <li>
            <a href="/">HOME</a>
        </li>
        
        <li>
            <a href="/archives">ARCHIVE</a>
        </li>
        
        <li>
            <a href="/categories">CATEGORIES</a>
        </li>
        
        <li>
            <a href="/tags">TAGS</a>
        </li>
        
        <li>
            <a href="/links">LINKS</a>
        </li>
        
        <li>
            <a href="/about">ABOUT</a>
        </li>
        
    </ul>
    <div class="my_foot">
        
        <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
            <img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
        </a>
        
    </div>
</div>
<div class='shelter'>
</div>
<style>
    .shelter{
        background-color: #333;
        opacity:0.5;
        cursor: pointer;
        display: none; 
        position: fixed;
        left: 0;
        top: 0; 
        right: 0;
        bottom: 0;
        z-index: 1998;
    }
    .sidebar {
        width: 66%;
        height: 100%;
        position: fixed;
        top: 0;
        right: -100%;
        bottom: 0;
        background: #fff;
        z-index: 1999;
        text-align: center;
        box-shadow: -6px 0 20px rgba(98, 94, 94, .815);
    }

    .topo {
        width: 100%;
        height: 200px;
        background: url(https://api.ixiaowai.cn/gqapi/gqapi.php) no-repeat;
        background-size: 100% 100%;
        position: relative;
        display: flex;
        align-items: flex-end
    }

    .topo h2 {
        color: #fff;
        z-index: 1;
        position: relative;
        margin: 0 0 10px 10px;
        font-size: 1.2em;
        box-sizing: border-box
    }

    .topo:before {
        content: '';
        background-image: url(/image/pattern.png);
        background-repeat: repeat;
        height: 100%;
        left: 0;
        position: absolute;
        top: 0;
        width: 100%;
        z-index: 1
    }

    .sidebar ul {
        width: 100%;
        margin-top: 50px
    }

    .sidebar ul li {
        height: 50px;
        list-style: none;
        font-size: 1.2em;
        text-align: right;
        margin-right: 10px
    }

    .sidebar ul li a {
        display: grid;
        color: #5d606a;
        text-overflow: ellipsis;
        width: 100%;
        text-decoration: none
    }

    .my_foot {
        width: 100%;
        padding: 10px;
        margin-bottom: 10px;
        position: absolute;
        bottom: 0
    }

    .my_foot a {
        text-decoration: none;
        margin-right: 10px;
        display: inline-block
    }

    .my_foot a img {
        width: 30px;
        height: 30px
    }
</style>

<script>
    $( function () {
	$( '.h-right-close>svg' )
		.click( function () {
			$( '.sidebar' )
				.animate( {
					right: "0"
				}, 500 );
			$( '.shelter' )
				.fadeIn( "slow" )
		} );
	$( '.shelter' )
		.click( function ( e ) {
			$( '.sidebar' )
				.animate( {
					right: "-100%"
				}, 500 );
			$( '.shelter' )
				.fadeOut( "slow" )
		} )
} )

</script>

<div class="post">
    <div class="post-header-background post-header-color"
    style="background: url('')" 
>
    <div class="post-header-background-content">
        <ul class="post-header-tag">
            
            
            <li><a href="/tags/前端">前端</a></li>
            
            <li><a href="/tags/学习笔记">学习笔记</a></li>
            
            <li><a href="/tags/JavaScript">JavaScript</a></li>
            
            
        </ul>
        
        <h1>JavaScript高级</h1>
        <div class="post-header-info">
            <div class="post-header-info-author">
                
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 20 20">
                        <g>
                            <path fill="#12183A"
                                d="M6.187 15.265A6.47 6.47 0 0 0 10 16.5a6.47 6.47 0 0 0 3.813-1.235A4.99 4.99 0 0 0 10 13.5a4.99 4.99 0 0 0-3.813 1.765zM5.082 14.25A6.485 6.485 0 0 1 10 12c1.965 0 3.726.872 4.918 2.25a6.5 6.5 0 1 0-9.836 0zM10 18a8 8 0 1 1 0-16 8 8 0 0 1 0 16zm0-7a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0-1.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z">
                            </path>
                        </g>
                    </svg>
                
                <span class="post-header-info-author-text"> <a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">Sheep</a></span>
                <div class="post-header-info-author-categories">
                    
                         <a href="../../categories/JavaScript/" target="_blank" >JavaScript</a>
                    
                </div>
                <p>2022-11-11 20:33:36</p>
            </div>
        </div>
    </div>
</div>
    <div class="post-content" id="content">
  
  <div id="article" class="post-content-info">
    

    <h1 id="1-JS-面向对象"><a href="#1-JS-面向对象" class="headerlink" title="1. JS 面向对象"></a>1. JS 面向对象</h1><h2 id="1-1-面向对象编程介绍"><a href="#1-1-面向对象编程介绍" class="headerlink" title="1.1 面向对象编程介绍"></a>1.1 面向对象编程介绍</h2><blockquote>
<p>面向过程编程 POP</p>
<ul>
<li>&#x3D;&#x3D;面向过程&#x3D;&#x3D;就是分析出解决问题所需要的&#x3D;&#x3D;步骤&#x3D;&#x3D;，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了</li>
</ul>
</blockquote>
<h3 id="1-1-1-面向对象编程-OOP（Object-Oriented-Programming"><a href="#1-1-1-面向对象编程-OOP（Object-Oriented-Programming" class="headerlink" title="1.1.1 面向对象编程 OOP（Object Oriented Programming)"></a>1.1.1 面向对象编程 OOP（Object Oriented Programming)</h3><ul>
<li>&#x3D;&#x3D;面向对象&#x3D;&#x3D;是把事务分解成为一个个对象，然后由对象之间分工合作。</li>
<li>&#x3D;&#x3D;面向对象是以对象功能来划分问题，而不是步骤。&#x3D;&#x3D;</li>
</ul>
<h3 id="1-1-2-面向对象的特性"><a href="#1-1-2-面向对象的特性" class="headerlink" title="1.1.2 面向对象的特性"></a>1.1.2 面向对象的特性</h3><ul>
<li>封装性</li>
<li>继承性</li>
<li>多态性</li>
</ul>
<h3 id="1-1-3-面向对象和面向过程的对比"><a href="#1-1-3-面向对象和面向过程的对比" class="headerlink" title="1.1.3 面向对象和面向过程的对比"></a>1.1.3 面向对象和面向过程的对比</h3><ul>
<li>面向过程<ul>
<li>优点：性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</li>
<li>缺点：没有面向对象易维护、易复用、易扩展</li>
</ul>
</li>
<li>面向对象<ul>
<li>优点：易维护、易复用、易扩展，由于面向对象有封装、继承、多态的特性，可以设计出低耦合的系统，是系统更加灵活易于维护</li>
<li>缺点：性能比面向过程低</li>
</ul>
</li>
</ul>
<h2 id="1-2-ES6-中的类和对象"><a href="#1-2-ES6-中的类和对象" class="headerlink" title="1.2 ES6 中的类和对象"></a>1.2 ES6 中的类和对象</h2><ul>
<li>&#x3D;&#x3D;面向对象的思维特点&#x3D;&#x3D;<ul>
<li>抽取（抽象）&#x3D;&#x3D;对象共用的属性和行为&#x3D;&#x3D;封装成一个&#x3D;&#x3D;类&#x3D;&#x3D;</li>
<li>对类进行&#x3D;&#x3D;实例化&#x3D;&#x3D;，获取类的对象</li>
</ul>
</li>
</ul>
<h3 id="1-2-1-对象"><a href="#1-2-1-对象" class="headerlink" title="1.2.1 对象"></a>1.2.1 对象</h3><ul>
<li>在 JS 中，对象是一组&#x3D;&#x3D;无序的相关属性和方法的集合&#x3D;&#x3D;，所有的事物都是对象，例如字符串、数值、数组、函数等</li>
<li>对象&#x3D;&#x3D;特指&#x3D;&#x3D;某一个，通过实例化一个具体的对象</li>
<li>对象是由&#x3D;&#x3D;属性&#x3D;&#x3D;和&#x3D;&#x3D;方法&#x3D;&#x3D;组成的<ul>
<li>属性：事物的&#x3D;&#x3D;特征&#x3D;&#x3D;，在对象中用&#x3D;&#x3D;属性&#x3D;&#x3D;来表示（常用名词）</li>
<li>方法：事物的&#x3D;&#x3D;行为&#x3D;&#x3D;，在对象中用&#x3D;&#x3D;方法&#x3D;&#x3D;来表示（常用动词）</li>
</ul>
</li>
</ul>
<h3 id="1-2-2-类-class"><a href="#1-2-2-类-class" class="headerlink" title="1.2.2 类 class"></a>1.2.2 类 class</h3><ul>
<li><p>&#x3D;&#x3D;类&#x3D;&#x3D;抽象了对象的公共部分，它&#x3D;&#x3D;泛指&#x3D;&#x3D;某一大类（class）</p>
</li>
<li><p>类的本质还是一个函数（function），我们可以简单地理解为，类就是构造函数的另外一种写法。</p>
</li>
<li><p>类的特点：</p>
<ul>
<li><p>类有原型对象 prototype</p>
</li>
<li><p>类原型对象 prototype 里面有 constructor 指向类本身</p>
</li>
<li><p>类可以通过原型对象添加方法</p>
<pre><code class="javascript">class Star &#123;
    
&#125;
Star.prototype.sing = function() &#123;
    console.log(&#39;hello&#39;)
&#125;
console.log(Star.prototype);
</code></pre>
</li>
<li><p>类创建的实例对象有 <code>__prototype__</code>原型指向类的原型对象</p>
</li>
</ul>
</li>
<li><p>ES6 的类就是一种语法糖</p>
<ul>
<li>语法糖就是一种便捷写法。两种方法可以实现同样的功能，其中一种更方便清晰，那么这个方法就是语法糖</li>
</ul>
</li>
</ul>
<h4 id="（1）创建类"><a href="#（1）创建类" class="headerlink" title="（1）创建类"></a>（1）创建类</h4><ul>
<li><p>语法：</p>
<ul>
<li>类名习惯性地&#x3D;&#x3D;首字母大写&#x3D;&#x3D;</li>
</ul>
<pre><code class="javascript">class Name &#123;
    // class body
&#125;
</code></pre>
</li>
<li><p>创建实例：</p>
<ul>
<li>&#x3D;&#x3D;类必须使用 new 来实例化对象&#x3D;&#x3D;</li>
</ul>
<pre><code class="javascript">let xx = new name();
</code></pre>
</li>
</ul>
<h4 id="（2）类-constructor-构造函数"><a href="#（2）类-constructor-构造函数" class="headerlink" title="（2）类 constructor 构造函数"></a>（2）类 constructor 构造函数</h4><ul>
<li><p>&#x3D;&#x3D;constructor()&#x3D;&#x3D;方法是类的&#x3D;&#x3D;构造函数&#x3D;&#x3D;（默认方法），用于&#x3D;&#x3D;传递参数，返回实例对象&#x3D;&#x3D;，&#x3D;&#x3D;通过 new 命令生成对象实例时，自动调用该方法&#x3D;&#x3D;。如果没有显示定义，类内部会自动给我们创建一个 constructor()</p>
</li>
<li><p>创建类 类名后面不要加小括号，生成实例 类名后面加小括号，构造函数不需要加 function</p>
</li>
<li><p>完整创建实例：</p>
<pre><code class="javascript">// 1.创建类 class 创建一个明星类
class Star &#123;
    // 类的共有属性放在 constructor 里面
    constructor(uname,age) &#123;
        // this 指向的是实例化对象 ldh、zxy...
        this.uname = uname;
        this.age = age;
    &#125;
&#125;
// 2.利用类创建对象 new
let ldh = new Star(&#39;刘德华&#39;,18);
let zxy = new Star(&#39;张学友&#39;,20);
</code></pre>
</li>
</ul>
<h4 id="（3）在类中添加方法"><a href="#（3）在类中添加方法" class="headerlink" title="（3）在类中添加方法"></a>（3）在类中添加方法</h4><ul>
<li><p>语法：</p>
<ul>
<li>类里面所有的函数&#x3D;&#x3D;不需要写 function&#x3D;&#x3D;</li>
<li>多个函数方法之间&#x3D;&#x3D;不需要添加逗号分隔&#x3D;&#x3D;</li>
</ul>
<pre><code class="javascript">class Star &#123;
    constructor(uname,age) &#123;
        this.uname = uname;
        this.age = age;
    &#125;
    // 添加方法 接收参数
    sing(song) &#123;
        console.log(this.uname + song)
    &#125;
&#125;

let ldh = new Star(&#39;刘德华&#39;,18);
let zxy = new Star(&#39;张学友&#39;,20);
// 调用方法 传递参数
ldh.sing(&#39;好运来&#39;)；
zxy.sing(&#39;unravel&#39;);
</code></pre>
</li>
</ul>
<h4 id="（4）使用类的注意事项"><a href="#（4）使用类的注意事项" class="headerlink" title="（4）使用类的注意事项"></a>（4）使用类的注意事项</h4><ul>
<li><p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p>
</li>
<li><p>&#x3D;&#x3D;类里面的共有的属性和方法一定要加 this 使用&#x3D;&#x3D; 因为 this 是指向实例化对象的</p>
<pre><code class="javascript">class Star &#123;
    constructor(uname,age) &#123;
        this.uname = uname;
        this.age = age;
        this.sing();// 实例化对象时，直接调用 sing 方法
    &#125;
    sing() &#123;
        console.log(this.name);//共有的属性和方法一定要加 this 使用
    &#125;
&#125;

let ldh = new Star(&#39;刘德华&#39;);// 实例化对象会直接调用 construction
// ldh.sing()
</code></pre>
</li>
<li><p>&#x3D;&#x3D;类里面 this 指向问题&#x3D;&#x3D;</p>
<ul>
<li><p>constructor 里面的 this 指向的是创建的实例对象</p>
</li>
<li><p>方法里面的 this 指向的是这个方法的调用者</p>
<pre><code class="html">&lt;button&gt;点击&lt;/button&gt;
&lt;script&gt;
    class Star &#123;
        constructor(uname,age) &#123;
            // constructor 里面的 this 指向的是创建的实例对象
            this.uname = uname;
            this.age = age;
            // this.sing();
            this.btn = document.querySelector(&#39;button&#39;);
            this.btn.onclick = this.sing;
        &#125;
        sing() &#123;
            // 这个 sing 方法里面的 this 指向的是 btn
            console.log(this.name);
        &#125;
        dance() &#123;
            // 方法里面的 this 指向的是这个方法的调用者 ldh
            console.log(this);
        &#125;
    &#125;
    
    let ldh = new Star(&#39;刘德华&#39;);
    ldh.dance()
&lt;/script&gt;
</code></pre>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-类的继承"><a href="#1-3-类的继承" class="headerlink" title="1.3 类的继承"></a>1.3 类的继承</h2><h3 id="1-3-1-语法"><a href="#1-3-1-语法" class="headerlink" title="1.3.1 语法"></a>1.3.1 语法</h3><ul>
<li><p>&#x3D;&#x3D;extends&#x3D;&#x3D; 继承</p>
</li>
<li><p>代码示例：</p>
<pre><code class="javascript">class Father &#123;
    // 父类
    constructor() &#123;    
    &#125;
    money() &#123;
        console(100);
    &#125;
&#125;
class Son extends Father &#123;
    // 子类继承父类
&#125;

let son = new Son();
son.money(); // 100
</code></pre>
</li>
</ul>
<h3 id="1-3-2-super-关键字"><a href="#1-3-2-super-关键字" class="headerlink" title="1.3.2 super 关键字"></a>1.3.2 super 关键字</h3><ul>
<li><p>&#x3D;&#x3D;super 关键字&#x3D;&#x3D;用于访问和调用对象父类上的函数。&#x3D;&#x3D;可以调用父类的构造函数&#x3D;&#x3D;，也可以调用父类的普通函数。</p>
</li>
<li><p>super 关键字调用父类构造函数：</p>
<pre><code class="javascript">class Father &#123;
    // 父类
    constructor(x,y) &#123;   
        this.x = x;
        this.y = y;
    &#125;
    sum() &#123;
        console(this.x + this.y);
    &#125;
&#125;
class Son extends Father &#123;
    // 子类继承父类
    constructor(x,y) &#123;
        super(x，y); // 调用了父类中的构造函数
    &#125;
&#125;

let son = new Son(1,2);
son.sum();
</code></pre>
</li>
<li><p>super 关键字调用父类普通函数</p>
<ul>
<li><p>继承中，如果实例化子类输出一个方法，&#x3D;&#x3D;先看这个子类有没有这个方法&#x3D;&#x3D;，如果有就先执行子类的</p>
</li>
<li><p>继承中，如果子类没有，&#x3D;&#x3D;就去查找父类有没有这个方法&#x3D;&#x3D;，如果有就执行父类这个方法（&#x3D;&#x3D;就近原则&#x3D;&#x3D;）</p>
<pre><code class="javascript">class Father &#123;
    say() &#123;
        return &#39;我是爸爸&#39;;
    &#125;
&#125;
class Son extends Father &#123;
    say() &#123;
        // super.say() 就是调用父类中的普通函数 say()
        console.log(super.say() + &#39;的儿子&#39;);
    &#125;
&#125;

let son = new Son();
son.say();// 我是爸爸的儿子
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="1-3-3-子类继承父类方法并拓展自己的方法"><a href="#1-3-3-子类继承父类方法并拓展自己的方法" class="headerlink" title="1.3.3 子类继承父类方法并拓展自己的方法"></a>1.3.3 子类继承父类方法并拓展自己的方法</h3><ul>
<li><p>&#x3D;&#x3D;子类在构造函数中使用 super，必须放到 this 前面（必须先调用父类的构造方法，再使用子类构造方法&#x3D;&#x3D;</p>
</li>
<li><p>代码实例</p>
<pre><code class="javascript">class Father &#123;
    constructor(x,y) &#123;
        this.x = x;
        this.y = y;
    &#125;
    sum() &#123;
        console.log(this.x + this.y);
    &#125;
&#125;
// 子类继承父类方法并拓展自己的方法
class Son extends Father &#123;
    constructor(x,y) &#123;
        // 利用 super 调用父亲的构造函数
        // super 必须在子类 this 之前调用
        super(x,y);
        this.x = x;
        this.y = y;
    &#125;
    subtract() &#123;
        console.log(this.x - this.y)
    &#125;
&#125;

let son = new Son(5,3)
son.sum();
</code></pre>
</li>
</ul>
<h2 id="1-4-面向对象案例"><a href="#1-4-面向对象案例" class="headerlink" title="1.4 面向对象案例"></a>1.4 面向对象案例</h2><h3 id="1-4-1-面向对象版-tab-栏切换"><a href="#1-4-1-面向对象版-tab-栏切换" class="headerlink" title="1.4.1 面向对象版 tab 栏切换"></a>1.4.1 面向对象版 tab 栏切换</h3><ul>
<li><p>功能需求：</p>
<ul>
<li>点击 tab 栏，可以切换效果</li>
<li>点击 + 号，可以添加 tab 项和内容项</li>
<li>点击 x 号，可以删除当前的 tab 项和内容项</li>
<li>双击 tab 项文字或者内容项文字，可以修改里面的文字内容</li>
</ul>
</li>
<li><p>部分代码 index.js</p>
<pre><code class="javascript">let that;
class Tab &#123;
    constructor(id) &#123;
        // 获取元素
        that = this;
        this.main = document.querySelector(id);
        this.add = this.main.querySelector(&#39;.tabadd&#39;);
        // li 的父元素
        this.ul = this.main.querySelector(&#39;.firstnav ul:first-child&#39;);
        // section 的父元素
        this.fsection = this.main.querySelector(&#39;.tabscon&#39;);
        this.init();
    &#125;
    init() &#123;
        this.updateNode();// 获取元素
        // init 初始化操作让相关的元素绑定事件
        for (let i = 0; i &lt; this.lis.length; i++) &#123;
            this.lis[i].index = i;
            this.lis[i].onclick = this.toggleTab.bind(this.lis[i],this);// 把 constructor 的 this 当作参数传递给 toggleTab 的形参 that
            this.remove[i].onclick = this.removeTab.bind(this.remove[i],this);
            // 双击事件是 ondblclick
            this.spans[i].ondblclick = this.editTab;
            this.sections[i].ondblclick = this.editTab;
        &#125;
        this.add.onclick = this.addTab.bind(this.add,this);
    &#125;;  
    // 获取所有的 li、section 、remove、span
        // 因为页面加载时 获取的 li 和 section 不包含后面添加的 li 和 section
    updateNode() &#123;
        this.lis = this.main.querySelectorAll(&#39;li&#39;);
        this.sections = this.main.querySelectorAll(&#39;section&#39;);
        this.remove = this.main.querySelectorAll(&#39;.icon-guanbi&#39;);
        this.spans = this.main.querySelectorAll(&#39;.firstnav li span:first-child&#39;);
    &#125;;
    // 1. 切换功能
    toggleTab(that) &#123;
        // console.log(this.index);
        that.clearClass();
        // 添加类 liactive 去掉下边框
        this.className = &#39;liactive&#39;;// 这里的 this 指向 li
        that.sections[this.index].className = &#39;conactive&#39;;
        // 添加类 display 显示
    &#125;
    // 清除样式：消灭所有人
    clearClass() &#123;
        // clearClass 是 that 来调用的 所以这里的 this 就是指向constructor
        for (let i = 0; i &lt; this.lis.length; i++) &#123;
            this.lis[i].className = &#39;&#39;;
            this.sections[i].className = &#39;&#39;;
        &#125;
    &#125;

    // 2. 添加功能
    addTab(that) &#123;
        that.clearClass();// 清除样式
        // (1) 创建新的选项卡 li 和新的内容 section
            // 利用 insertAdjacentHTML() 可以直接把字符串格式添加到父元素中
            let random = Math.random();// 生成一个随机数 与前面的序列号相区别
            let li = &#39;&lt;li class=&quot;liactive&quot;&gt;&lt;span&gt;新选项卡&lt;/span&gt;&lt;span class=&quot;iconfont icon-guanbi&quot;&gt;&lt;/span&gt;&lt;/li&gt;&#39;;
            let section = &#39;&lt;section class=&quot;conactive&quot;&gt;测试 &#39;+ random +&#39;&lt;/section&gt;&#39;;
        // (2) 把创建的两个元素追加到对应的父元素中
            // this 指向的是按钮 按钮里没有 ul
            that.ul.insertAdjacentHTML(&#39;beforeend&#39;,li);
            that.fsection.insertAdjacentHTML(&#39;beforeend&#39;,section);
            that.init();// 给新创建的 li 和 section 添加切换事件
    &#125;
    // 3. 删除功能
    removeTab(that,e) &#123;
        e.stopPropagation();// 阻止冒泡 避免触发 li 的切换点击事件
        // x 是没有索引号的，但他的父亲 li 有索引号，这个索引号正是我们想要的索引号
        let index = this.parentNode.index;
        console.log(index);
        // 根据索引号删除对应的 li 和 section remove 方法可以直接删除指定元素
        that.lis[index].remove();
        that.sections[index].remove();
        that.init();// 重新获取最新的元素

        // 当我们删除的不是选中状态的 li 时，让原来选中状态的 li 保持不变
        if (document.querySelector(&#39;.liactive&#39;)) return;// return 后的代码不执行

        // 当我们删除了选中状态的 li 时，让他前一个 li 处于选定状态
        index--;
        // 手动调用点击事件不需要鼠标触发
        if(index &lt; 0) &#123;
            index = 0;
        &#125;
        that.lis[index].click();
    &#125;
    // 4. 修改功能
    // 双击选项卡 li 或 section 里面的文字，可以实现修改功能
    // 核心思路：双击文字的时候，在里面生成一个文本框，当失去焦点或按下回车再把文本框输入的值赋给原先元素
    editTab() &#123;
        let str = this.innerHTML;// 获取 span 内容
        // 禁止双击选中文字
        window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty();
        // 生成一个文本框
        this.innerHTML = &#39;&lt;input type=&quot;text&quot; /&gt;&#39;;
        let input = this.children[0]; // 文本框是 这个span的第0个孩子
        input.value = str;
        input.select();// 让文本框内的文字处于全选状态
        // 当我们离开文本框 就把文本框里的值 赋给 span
        input.onblur = function() &#123;
            this.parentNode.innerHTML = this.value;
        &#125;
    // 按下回车也可以把文本框内的值赋给 span
        input.onkeyup = function(e) &#123;
            if(e.keyCode === 13) &#123;
                // 手动调用表单失去焦点事件 不需要鼠标离开操作
                this.blur();
            &#125;
        &#125;
    &#125;
&#125;

new Tab(&#39;#tab&#39;);
</code></pre>
</li>
</ul>
<h1 id="2-构造函数和原型"><a href="#2-构造函数和原型" class="headerlink" title="2. 构造函数和原型"></a>2. 构造函数和原型</h1><h2 id="2-1-构造函数和原型"><a href="#2-1-构造函数和原型" class="headerlink" title="2.1 构造函数和原型"></a>2.1 构造函数和原型</h2><ul>
<li>ES6 之前，JS 中并没有引用类的概念，对象不是基于类创建的，而是用一种称为&#x3D;&#x3D;构造函数&#x3D;&#x3D;的特殊函数来定义对象和它们的特征。</li>
<li>一般情况下，我们的公共属性定义在构造函数里面，公共的方法我们放到原型对象上</li>
<li>构造函数的特点<ul>
<li>构造函数有原型对象 prototype</li>
<li>构造函数原型对象 prototype 里面有 constructor 指向构造函数本身</li>
<li>构造函数可以通过原型对象添加方法</li>
<li>构造函数创建的实例对象有 <code>__prototype__</code>原型指向构造函数的原型对象</li>
</ul>
</li>
</ul>
<h3 id="2-1-1-创建对象的三种方式"><a href="#2-1-1-创建对象的三种方式" class="headerlink" title="2.1.1 创建对象的三种方式"></a>2.1.1 创建对象的三种方式</h3><ul>
<li><p>对象字面量</p>
<pre><code class="javascript">let obj1 = &#123;&#125;;
</code></pre>
</li>
<li><p>new Object()</p>
<pre><code class="javascript">let obj2 = new Object();
</code></pre>
</li>
<li><p>自定义构造函数</p>
<ul>
<li>new 在执行时会做的四件事<ul>
<li>在内存中创建一个新的空对象</li>
<li>让 this 指向这个新的对象</li>
<li>执行构造函数里面的代码，给这个新对象添加属性和方法</li>
<li>返回这个新对象（所以&#x3D;&#x3D;构造函数里面不需要 return&#x3D;&#x3D;）</li>
</ul>
</li>
</ul>
<pre><code class="javascript">function Star(uname,age) &#123;
    this.uname = uname;
    this.age = age;
    this.sing = function() &#123;
        console.log(&#39;我会唱歌&#39;);
    &#125;
&#125;
let ldh = new Star(&#39;刘德华&#39;,18)；
</code></pre>
</li>
</ul>
<h3 id="2-1-2-构造函数的成员"><a href="#2-1-2-构造函数的成员" class="headerlink" title="2.1.2 构造函数的成员"></a>2.1.2 构造函数的成员</h3><ul>
<li><p>静态成员：在&#x3D;&#x3D;构造函数本身上添加的&#x3D;&#x3D;成员称为&#x3D;&#x3D;静态成员&#x3D;&#x3D;，只能&#x3D;&#x3D;由构造函数本身来访问&#x3D;&#x3D;</p>
<pre><code class="javascript">Star.sex = &#39;男&#39;；// sex 就是静态成员
console.log(Star.sex);
console.log(ldh.sex);// undefined 不能通过对象来访问
</code></pre>
</li>
<li><p>实例成员：在&#x3D;&#x3D;构造函数内部通过this创建的&#x3D;&#x3D;对象成员称为&#x3D;&#x3D;实例成员&#x3D;&#x3D;，只能&#x3D;&#x3D;由实例化的对象来访问&#x3D;&#x3D;</p>
<pre><code class="javascript">console.log(ldh.uname);
ldh.sing();
console.log(Star.uname);// undefined 不可以通过构造函数来访问实例成员
</code></pre>
</li>
</ul>
<h3 id="2-1-3-构造函数的问题"><a href="#2-1-3-构造函数的问题" class="headerlink" title="2.1.3 构造函数的问题"></a>2.1.3 构造函数的问题</h3><ul>
<li><p>浪费内存</p>
<ul>
<li><p>每实例化一个对象，就会开辟一个新的内存地址来存放同样的函数方法</p>
<p><img src="E:\sheep\study\notes\images\构造函数内存问题.png" alt="构造函数内存问题"></p>
</li>
</ul>
</li>
</ul>
<h3 id="2-1-4-构造函数原型-prototype"><a href="#2-1-4-构造函数原型-prototype" class="headerlink" title="2.1.4 构造函数原型 prototype"></a>2.1.4 构造函数原型 prototype</h3><ul>
<li><p>构造函数通过原型分配的函数是所有对象所&#x3D;&#x3D;共享&#x3D;&#x3D;的</p>
</li>
<li><p>JS 规定，&#x3D;&#x3D;每一个构造函数都有一个 prototype 属性&#x3D;&#x3D;（原型对象），指向另一个对象。这个 &#x3D;&#x3D;prototype 就是一个对象&#x3D;&#x3D;，这个对象的&#x3D;&#x3D;所有属性和方法&#x3D;&#x3D;，&#x3D;&#x3D;都会被构造函数所拥有&#x3D;&#x3D;。、</p>
</li>
<li><p>我们可以把那些&#x3D;&#x3D;不变的方法&#x3D;&#x3D;，直接&#x3D;&#x3D;定义在 prototype 对象上&#x3D;&#x3D;，这样所有对象的实例就可以&#x3D;&#x3D;共享&#x3D;&#x3D;这些方法</p>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">function Star(uname,age) &#123;
    this.uname = uname;
    this.age = age;
&#125;
// 原型对象
Star.prototype.sing = function() &#123;
    console.log(&#39;我会唱歌&#39;);
&#125;
let ldh = new Star(&#39;刘德华&#39;,18)；
ldh.sing();
</code></pre>
</li>
</ul>
<h3 id="2-1-5-对象原型-proto"><a href="#2-1-5-对象原型-proto" class="headerlink" title="2.1.5 对象原型 __ proto __"></a>2.1.5 对象原型 __ proto __</h3><p>&#x3D;&#x3D;对象都会有一个属性 <code>__proto__</code>指向构造函数的 prototype 原型对象&#x3D;&#x3D;，之所以我们对象可以使用构造函数 prototype 原型对象的的属性和方法，就是因为对象有 <code>__proto__ </code>原型的存在。</p>
<ul>
<li>方法的查找规则：<ul>
<li>首先先看 ldh 对象身上是否有 sing 方法，如果有就执行这个对象上的 sing</li>
<li>如果没有 sing 这个方法，因为有  <code>__proto__</code>的存在，就去构造函数原型对象 prototype 身上去查找 sing 这个方法</li>
</ul>
</li>
</ul>
<h3 id="2-1-6-constructor-函数"><a href="#2-1-6-constructor-函数" class="headerlink" title="2.1.6 constructor 函数"></a>2.1.6 constructor 函数</h3><ul>
<li><p>对象原型（<code>__proto__</code>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性，constructor 我们称为构造函数，因为它&#x3D;&#x3D;指回构造函数本身&#x3D;&#x3D;</p>
</li>
<li><p>constructor 主要用于记录该对象引用于哪个构造函数。很多情况下，&#x3D;&#x3D;我们需要手动的利用 constructor 这个属性指回 原来的构造函数&#x3D;&#x3D;</p>
<pre><code class="javascript">        function Star(uname, age) &#123;
            this.uname = uname;
            this.age = age;
        &#125;
        // 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数
        // Star.prototype.sing = function() &#123;
        //     console.log(&#39;我会唱歌&#39;);
        // &#125;;
        // Star.prototype.movie = function() &#123;
        //     console.log(&#39;我会演电影&#39;);
        // &#125;
        Star.prototype = &#123;
            // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数
            constructor: Star,
            sing: function() &#123;
                console.log(&#39;我会唱歌&#39;);
            &#125;,
            movie: function() &#123;
                console.log(&#39;我会演电影&#39;);
            &#125;
        &#125;
        var ldh = new Star(&#39;刘德华&#39;, 18);
        var zxy = new Star(&#39;张学友&#39;, 19);
        console.log(Star.prototype);
        console.log(ldh.__proto__);
        console.log(Star.prototype.constructor);
        console.log(ldh.__proto__.constructor);
</code></pre>
</li>
</ul>
<h3 id="2-1-7-构造函数、实例、原型对象三者之间的关系"><a href="#2-1-7-构造函数、实例、原型对象三者之间的关系" class="headerlink" title="2.1.7 构造函数、实例、原型对象三者之间的关系"></a>2.1.7 构造函数、实例、原型对象三者之间的关系</h3><img src="E:\sheep\study\notes\images\构造函数、实例、原型对象三者之间的关系.png" alt="构造函数、实例、原型对象三者之间的关系" style="zoom: 50%;" />

<h3 id="2-1-8-原型链"><a href="#2-1-8-原型链" class="headerlink" title="2.1.8 原型链"></a>2.1.8 原型链</h3><p><img src="E:\sheep\study\notes\images\原型链.png" alt="原型链"></p>
<h3 id="2-1-9-JavaScript-的成员查找机制"><a href="#2-1-9-JavaScript-的成员查找机制" class="headerlink" title="2.1.9 JavaScript 的成员查找机制"></a>2.1.9 JavaScript 的成员查找机制</h3><ul>
<li>当访问一个对象的属性（包括方法）时，首先查找这个&#x3D;&#x3D;对象自身&#x3D;&#x3D;有没有该属性</li>
<li>如果没有就查找它的原型（也就是<code>__proto__</code>指向的 &#x3D;&#x3D;prototype 原型对象&#x3D;&#x3D;）</li>
<li>如果还没有就查找原型对象的模型（&#x3D;&#x3D;Object 的原型对象&#x3D;&#x3D;）</li>
<li>以此类推一直找到 Object 为止（&#x3D;&#x3D;null&#x3D;&#x3D;）</li>
</ul>
<h3 id="2-1-10-原型对象的应用-拓展内置对象方法"><a href="#2-1-10-原型对象的应用-拓展内置对象方法" class="headerlink" title="2.1.10 原型对象的应用 - 拓展内置对象方法"></a>2.1.10 原型对象的应用 - 拓展内置对象方法</h3><ul>
<li><p>&#x3D;&#x3D;注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype &#x3D; {} ，只能是 Array.prototype.xxx &#x3D; function() {} 的方式&#x3D;&#x3D;</p>
</li>
<li><p>代码实例</p>
<pre><code class="javascript">console.log(Array.prototype);
// 在原来的 prototype 后追加一个 sum 方法
Array.prototype.sum = function() &#123;
    let sum = 0;
    for (let i = 0; i &lt; this.length; i++) &#123;
        sum += this[i];
    &#125;
    return sum;
&#125;
//  = 直接覆盖掉了原先的 prototype 方法 就会报错 必须手动的利用constructor指回原来的构造函数,但这样操作以后 Array 里的其他方法也没有了
Array.prototype = &#123;
    constructor = Array;
    sum: function() &#123;
        let sum = 0;
        for (let i = 0; i &lt; this.length; i++) &#123;
            sum += this[i];
        &#125;
        return sum;
    &#125;
&#125;
let arr = [1,2,3];
console.log(arr.sum());
</code></pre>
</li>
</ul>
<h2 id="2-2-继承"><a href="#2-2-继承" class="headerlink" title="2.2 继承"></a>2.2 继承</h2><ul>
<li>es6 之前并没有给我们提供 extends 继承，我们可以通过&#x3D;&#x3D;构造函数+原型对象&#x3D;&#x3D;模拟实现继承，被称为&#x3D;&#x3D;组合继承&#x3D;&#x3D;</li>
</ul>
<h3 id="2-2-1-call"><a href="#2-2-1-call" class="headerlink" title="2.2.1 call()"></a>2.2.1 call()</h3><ul>
<li><p>&#x3D;&#x3D;调用&#x3D;&#x3D;这个&#x3D;&#x3D;函数&#x3D;&#x3D;，并且&#x3D;&#x3D;修改函数运行时的 this 指向&#x3D;&#x3D;</p>
<pre><code class="javascript">fun.call(thisArg,arg1,arg2,...)
</code></pre>
<ul>
<li><p>thisArg：当前调用函数 this 的指向对象</p>
</li>
<li><p>arg1、arg2：传递的其他参数</p>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">function fn(x,y) &#123;
    console.log(&#39;我想喝手磨咖啡&#39;);
    console.log(this);
&#125;
let o = &#123;
    name:&#39;andy&#39;
&#125;;
// fn();
// 1.call() 可以调用函数
fn.call();
// 1.call() 可以改变这个函数的this指向，此时这个函数的this就指向了o这个对象；参数1，2传给了x和y
fn.call(o,1,2);
</code></pre>
</li>
</ul>
</li>
</ul>
<h3 id="2-2-2-借用构造函数继承父类型属性"><a href="#2-2-2-借用构造函数继承父类型属性" class="headerlink" title="2.2.2 借用构造函数继承父类型属性"></a>2.2.2 借用构造函数继承父类型属性</h3><ul>
<li><p>核心原理：通过 &#x3D;&#x3D;call()&#x3D;&#x3D; 把父类型的 this 指向子类型的 this，这样就可以实现子类型继承父类型的&#x3D;&#x3D;属性&#x3D;&#x3D;。</p>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">// 1.父构造函数
function Father(uname,age) &#123;
    this.name = uname;
    this.age = age;
&#125;
// 2.子构造函数
function Son(uname,age,score) &#123;
    Father.call(this,uname,age);// 让父构造函数里的 this 改为指向子构造函数里的 this
    this.score = score;
&#125;
let son = new Son(&#39;刘德华&#39;,18,99);
console.log(son);
</code></pre>
</li>
</ul>
<h3 id="2-2-3-借用原型对象继承父类型方法"><a href="#2-2-3-借用原型对象继承父类型方法" class="headerlink" title="2.2.3 借用原型对象继承父类型方法"></a>2.2.3 借用原型对象继承父类型方法</h3><ul>
<li><p>&#x3D;&#x3D;先实例化父构造函数得到一个实例对象，再让 Son 的原型对象指向这个实例对象（忘了利用 constructor 指回原来的构造函数）&#x3D;&#x3D;</p>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">// 1.父构造函数
function Father() &#123;&#125;;
Father.prototype.money = function() &#123;
    console.log(&#39;100&#39;);
&#125;
// 2.子构造函数
function Son() &#123;&#125;;
// 继承父类型方法：
Son.prototype = new Father();
// 如果利用了对象的形式修改了原型对象，别忘了利用 constructor 指回原来的构造函数
Son.prototype.constructor = Son;

// son原型对象从father原型对象得到的是地址，son原型对象追加了，相当于在地址中做了修改，则父原型链对象也会改变
// Son.prototype = Father.prototype; 

let son = new Son();
console.log(son);
</code></pre>
</li>
</ul>
<h1 id="3-ES5-中的新增方法"><a href="#3-ES5-中的新增方法" class="headerlink" title="3. ES5 中的新增方法"></a>3. ES5 中的新增方法</h1><h3 id="3-1-数组方法"><a href="#3-1-数组方法" class="headerlink" title="3.1 数组方法"></a>3.1 数组方法</h3><ul>
<li>迭代（遍历方法）：forEach()、map()、filter()、some()、every()；</li>
</ul>
<h4 id="（1）forEach-x2F-map"><a href="#（1）forEach-x2F-map" class="headerlink" title="（1）forEach() &#x2F; map()"></a>（1）forEach() &#x2F; map()</h4><ul>
<li><p>currentValue：数组当前项的值</p>
</li>
<li><p>index：数组当前项的索引</p>
</li>
<li><p>arr：数组对象本身</p>
<pre><code class="javascript">array.forEach(function(currentValue,index,arr))
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let arr = [1,2,3];
let sum = 0;
arr.forEach(function(value,index,array) &#123;
    console.log(&#39;每个数组元素&#39; + value);
    console.log(&#39;每个数组元素的索引号&#39; + index);
    console.log(&#39;数组本身&#39; + array);
    // 数组求和
    sum += value;
&#125;)
console.log(sum);
</code></pre>
</li>
</ul>
<h4 id="（2）filter"><a href="#（2）filter" class="headerlink" title="（2）filter()"></a>（2）filter()</h4><ul>
<li><p>filter() 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，&#x3D;&#x3D;主要用于筛选数组&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;注意它直接返回一个新数组&#x3D;&#x3D;</p>
</li>
<li><p>currentValue：数组当前项的值</p>
</li>
<li><p>index：数组当前项的索引</p>
</li>
<li><p>arr：数组对象本身</p>
<pre><code class="javascript">array.filter(function(currentValue,index,arr))
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let arr = [12,66,4,88]
let newArr = arr.filter(function(value,index) &#123;
    // 直接在 return 后写条件
    // return value &gt;= 20;
    return value % 2 === 0;
&#125;);
console.log(newArr);
</code></pre>
</li>
</ul>
<h4 id="（3）some-x2F-every"><a href="#（3）some-x2F-every" class="headerlink" title="（3）some() &#x2F; every()"></a>（3）some() &#x2F; every()</h4><ul>
<li><p>some() 方法用于检测数组中的元素是否满足指定条件，通俗点：查找数组中是否有满足条件的元素</p>
</li>
<li><p>注意他返回的是&#x3D;&#x3D;布尔值&#x3D;&#x3D;，如果有则返回 true；没有则返回 false</p>
</li>
<li><p>如果找到第一个满足条件的元素，则终止循环，不再继续查找</p>
</li>
<li><p>currentValue：数组当前项的值</p>
</li>
<li><p>index：数组当前项的索引</p>
</li>
<li><p>arr：数组对象本身</p>
<pre><code class="javascript">array.some(function(currentValue,index,arr))
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let arr = [10,20,4];
let flag = arr.some(function(value) &#123;
    return value &gt;= 20;
&#125;);
console.log(flag);// true
</code></pre>
</li>
</ul>
<h4 id="（4）-查询商品案例"><a href="#（4）-查询商品案例" class="headerlink" title="（4） 查询商品案例"></a>（4） 查询商品案例</h4><ul>
<li><p>要求</p>
<ul>
<li>把数据渲染到页面中</li>
<li>根据价格显示数据</li>
<li>根据商品名称显示数据</li>
</ul>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">        // 利用新增数组方法操作数据
        let data = [&#123;
            id: 1,
            pname: &#39;小米&#39;,
            price: 3999
        &#125;,&#123;
            id: 2,
            pname: &#39;oppo&#39;,
            price: 999
        &#125;,&#123;
            id: 3,
            pname: &#39;荣耀&#39;,
            price: 1299
        &#125;,&#123;
            id: 4,
            pname: &#39;华为&#39;,
            price: 1999
        &#125;];
        // 1.获取相应的元素
        let tbody = document.querySelector(&#39;tbody&#39;);
        let start = document.querySelector(&#39;.start&#39;);
        let end = document.querySelector(&#39;.end&#39;);
        let searchPrice = document.querySelector(&#39;.search-price&#39;);
        let product = document.querySelector(&#39;.product&#39;);
        let searchPro = document.querySelector(&#39;.search-pro&#39;);
        // 2.数据渲染按到页面中
        setData(data);
        function setData(mydata) &#123;
            // 先清空原来tbody 里面的数据
            tbody.innerHTML = &#39;&#39;;
            mydata.forEach(function(value) &#123;
            // console.log(value);
            // 定义节点格式
            let html = &#39;&lt;td&gt;&#39;+ value.id +&#39;&lt;/td&gt;&lt;td&gt;&#39;+ value.pname +&#39;&lt;/td&gt;&lt;td&gt;&#39;+ value.price +&#39;&lt;/td&gt;&#39;;
            // 利用 insertAdjacentHTML 创建并插入节点
            tbody.insertAdjacentHTML(&#39;beforeend&#39;,html);
        &#125;)
        &#125;;
        // 3.根据价格显示数据
        // 当我们点击了按钮,就可以根据我们的商品价格去筛选数组里面的对象
        searchPrice.onclick = function() &#123;
            let newData = data.filter(function(value) &#123;
                return value.price &gt;= start.value &amp;&amp; value.price &lt;= end.value;
            &#125;);
            // console.log(newData)
            // 把筛选完之后的对象渲染到页面中
            setData(newData);
        &#125;;
        // 4.根据商品名显示数据
        // 如果查询数组中唯一的元素, 用some方法更合适,因为它找到这个元素,就不在进行循环,效率更高
        searchPro.onclick = function() &#123;
            let arr = [];
            data.some(function(value) &#123;
                if (value.pname === product.value) &#123;
                    arr.push(value);
                    return true; // 不再进行下面的循环
                &#125;
            &#125;);
            // 把拿到的数据渲染到页面中
            setData(arr);
        &#125;
</code></pre>
</li>
</ul>
<h3 id="3-2-字符串方法"><a href="#3-2-字符串方法" class="headerlink" title="3.2 字符串方法"></a>3.2 字符串方法</h3><h4 id="（1）trim"><a href="#（1）trim" class="headerlink" title="（1）trim()"></a>（1）trim()</h4><ul>
<li><p>trim() 方法会从一个字符串的左右两端删除空白字符</p>
<pre><code class="javascript">str.trim()
</code></pre>
</li>
<li><p>trim() 方法并不影响字符串本身，它&#x3D;&#x3D;返回的是一个新的字符串&#x3D;&#x3D;。</p>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let str = &#39;   andy    &#39;;
let str1 = str.trim();
console.log(str1);
</code></pre>
</li>
</ul>
<h3 id="3-3-对象方法"><a href="#3-3-对象方法" class="headerlink" title="3.3 对象方法"></a>3.3 对象方法</h3><h4 id="（1）Object-keys"><a href="#（1）Object-keys" class="headerlink" title="（1）Object.keys()"></a>（1）Object.keys()</h4><ul>
<li><p>用于获取对象自身所有的属性</p>
<ul>
<li><p>效果类似于 for…in</p>
</li>
<li><p>&#x3D;&#x3D;返回一个由属性名组成的数组&#x3D;&#x3D;</p>
<pre><code class="javascript">Object.keys(obj)
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let obj = &#123;
    id: 1,
    pname: &#39;小米&#39;,
    price: 1999,
    num: 2000
&#125;;
// 获取对象自身所有属性名
let arr = Object.keys(obj);
console.log(arr);
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="（2）Object-defineProperty"><a href="#（2）Object-defineProperty" class="headerlink" title="（2）Object.defineProperty()"></a>（2）Object.defineProperty()</h4><ul>
<li><p>定义对象中新属性或修改原有的属性</p>
<ul>
<li><p>obj：必需，目标对象</p>
</li>
<li><p>prop：必需，需定义或修改的属性和名字</p>
</li>
<li><p>descriptor：必需，目标属性所拥有的特性</p>
<ul>
<li>value：设置属性的值 默认为 undefined</li>
<li>writable：值是否可以重写。true | false 默认为 false</li>
<li>enumerable：目标属性是否可以被枚举（遍历）。true | false 默认为 false</li>
<li>configurable：目标属性是否可以被删除或是否可以再次修改&#x3D;&#x3D;特性&#x3D;&#x3D; true | false 默认为 false</li>
</ul>
<pre><code class="javascript">Object.defineProperty(obj,prop,descriptor)
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let obj = &#123;
    id: 1,
    pname: &#39;小米&#39;,
    price: 1999
&#125;；
// 1.以前的对象添加和修改属性的方式
// obj.num = 1000;
// obj.price = 99;
// console.log(obj);
// 2.Object.defineProperty() 定义新属性或修改原有的属性
Object.definedProperty(obj,&#39;num&#39;, &#123;
    value: 1000 // 添加新属性
&#125;);
Object.definedProperty(obj,&#39;price&#39;, &#123;
    value: 9.9 // 修改原有的属性
&#125;);
Object.definedProperty(obj,&#39;id&#39;, &#123;
    // 不允许修改这个属性值
    writable: false;
&#125;);
console.log(obj);
</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="4-函数进阶"><a href="#4-函数进阶" class="headerlink" title="4. 函数进阶"></a>4. 函数进阶</h1><h2 id="4-1-函数的定义和调用"><a href="#4-1-函数的定义和调用" class="headerlink" title="4.1 函数的定义和调用"></a>4.1 函数的定义和调用</h2><blockquote>
<p>&#x3D;&#x3D;函数也属于对象&#x3D;&#x3D;</p>
</blockquote>
<h3 id="4-1-1-函数的定义方式"><a href="#4-1-1-函数的定义方式" class="headerlink" title="4.1.1 函数的定义方式"></a>4.1.1 函数的定义方式</h3><ul>
<li><p>自定义函数（命名函数）</p>
<pre><code class="javascript">function fn() &#123;&#125;;
</code></pre>
</li>
<li><p>函数表达式（匿名函数）</p>
<pre><code class="javascript">let fun = function() &#123;&#125;;
</code></pre>
</li>
<li><p>利用 new Function(‘参数1’,’参数2’….,’函数体’)</p>
<ul>
<li>Function 里面的&#x3D;&#x3D;参数&#x3D;&#x3D;必须是&#x3D;&#x3D;字符串格式&#x3D;&#x3D;</li>
<li>这种方式执行效率低，不方便书写，较少使用</li>
<li>&#x3D;&#x3D;所有函数都是 Function 的实例对象&#x3D;&#x3D;</li>
</ul>
<pre><code class="javascript">let f = new Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a + b)&#39;);
f(1,2);// 3
</code></pre>
</li>
</ul>
<h3 id="4-1-2-函数的原型三角关系"><a href="#4-1-2-函数的原型三角关系" class="headerlink" title="4.1.2 函数的原型三角关系"></a>4.1.2 函数的原型三角关系</h3><p><img src="E:\sheep\study\notes\images\函数的三角关系.png" alt="函数的三角关系"></p>
<h3 id="4-1-3-函数的调用方式"><a href="#4-1-3-函数的调用方式" class="headerlink" title="4.1.3 函数的调用方式"></a>4.1.3 函数的调用方式</h3><h4 id="（1）普通函数"><a href="#（1）普通函数" class="headerlink" title="（1）普通函数"></a>（1）普通函数</h4><ul>
<li>fn()</li>
<li>fn.call()</li>
</ul>
<pre><code class="javascript">function fn() &#123;
    console.log(&#39;123&#39;);
&#125;
fn();
fn.call();
</code></pre>
<h4 id="（2）对象的方法"><a href="#（2）对象的方法" class="headerlink" title="（2）对象的方法"></a>（2）对象的方法</h4><pre><code class="javascript">let o = &#123;
    sayHi: function() &#123;
        console.log(&#39;123&#39;)
    &#125;
&#125;
o.sayHi();
</code></pre>
<h4 id="（3）构造函数"><a href="#（3）构造函数" class="headerlink" title="（3）构造函数"></a>（3）构造函数</h4><pre><code class="javascript">function Star() &#123;&#125;;
new Star();
</code></pre>
<h4 id="（4）绑定事件函数"><a href="#（4）绑定事件函数" class="headerlink" title="（4）绑定事件函数"></a>（4）绑定事件函数</h4><pre><code class="javascript">btn.onclick = function() &#123;&#125;;// 点击了按钮就可以调用
</code></pre>
<h4 id="（5）定时器函数"><a href="#（5）定时器函数" class="headerlink" title="（5）定时器函数"></a>（5）定时器函数</h4><pre><code class="javascript">setInterval(function() &#123;&#125;,1000);// 每隔 1000ms 就调用一次
</code></pre>
<h4 id="（6）立即执行函数"><a href="#（6）立即执行函数" class="headerlink" title="（6）立即执行函数"></a>（6）立即执行函数</h4><pre><code class="javascript">(function() &#123;
    console.log(&#39;123&#39;)
&#125;());
// 立即执行函数是自动调用的
</code></pre>
<h2 id="4-2-this"><a href="#4-2-this" class="headerlink" title="4.2 this"></a>4.2 this</h2><h3 id="4-2-1-函数内-this-的指向"><a href="#4-2-1-函数内-this-的指向" class="headerlink" title="4.2.1 函数内 this 的指向"></a>4.2.1 函数内 this 的指向</h3><ul>
<li><p>this 的指向，是当我们调用函数时确定的，调用方式的不同决定了 this 的指向不同</p>
</li>
<li><p>一般指向我们的调用者</p>
<p><img src="E:\sheep\study\notes\images\函数内this的指向.png" alt="函数内this的指向"></p>
</li>
</ul>
<h3 id="4-2-2-改变函数内部-this-指向"><a href="#4-2-2-改变函数内部-this-指向" class="headerlink" title="4.2.2 改变函数内部 this 指向"></a>4.2.2 改变函数内部 this 指向</h3><blockquote>
<p>常用的有：bind()、call()、apply() 三种方法</p>
</blockquote>
<h4 id="（1）call-方法"><a href="#（1）call-方法" class="headerlink" title="（1）call 方法"></a>（1）call 方法</h4><ul>
<li><p>作用：</p>
<ul>
<li>调用函数</li>
<li>改变函数内的 this 指向</li>
<li>&#x3D;&#x3D;实现继承&#x3D;&#x3D;</li>
</ul>
</li>
<li><p>语法规范：</p>
<pre><code class="javascript">fun.call(thisArg,arg1,arg2,...)
</code></pre>
</li>
<li><p>代码实例：</p>
<p>&#96;&#96;&#96;javascript<br>&#x2F;&#x2F; 让 fn 的 this 指向 i<br>let i &#x3D; {<br>name: ‘andy’<br>}<br>function fn(a,b) {<br>console.log(this);<br>console.log(a + b);<br>};<br>fn.call(i,1,2);</p>
</li>
</ul>
<h4 id="（2）apply-方法"><a href="#（2）apply-方法" class="headerlink" title="（2）apply 方法"></a>（2）apply 方法</h4><ul>
<li><p>作用：</p>
<ul>
<li>调用函数</li>
<li>改变函数内的 this 指向</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>thisArg：在 fun 函数运行时指定的 this 值</li>
<li>argsArray：传递的值，必须包含在&#x3D;&#x3D;数组&#x3D;&#x3D;（伪数组）里面</li>
<li>返回值&#x3D;&#x3D;不是数组&#x3D;&#x3D;，是函数的返回值，因为它就是调用函数</li>
</ul>
<pre><code class="javascript">fun.apply(thisArg, [argsArray])
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">// 让 fn 的 this 指向 i
let i = &#123;
    name: &#39;andy&#39;
&#125;
function fn(arr) &#123;
    console.log(this);
    console.log(arr);// &#39;pink&#39;
&#125;;
fn.apply(i,[&#39;pink&#39;]);
</code></pre>
</li>
<li><p>apply 的主要应用</p>
<ul>
<li><p>apply 借助于数学内置对象 Math 求最大值 &#x2F; 最小值</p>
<pre><code class="javascript">let arr = [1,66,3,99,4];
let max = Math.max.apply(Math,arr);// 调用 Math.max 这个函数，不改变指向
let min = Math.min.apply(Math,arr);
console.log(max);// 99
console.log(min);// 1
</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="（3）bind-方法"><a href="#（3）bind-方法" class="headerlink" title="（3）bind 方法"></a>（3）bind 方法</h4><ul>
<li><p>作用：</p>
<ul>
<li>&#x3D;&#x3D;不调用函数&#x3D;&#x3D;，改变函数内的 this 指向</li>
</ul>
</li>
<li><p>语法规范</p>
<ul>
<li>thisArg：在 fun 函数运行时指定的 this 值</li>
<li>arg1、arg2：传递的其他参数</li>
<li>返回值是&#x3D;&#x3D;原函数改变 this 之后的新函数&#x3D;&#x3D;</li>
</ul>
<pre><code class="javascript">fun.bind(thisArg,arg1,arg2,...)
</code></pre>
</li>
<li><p>代码实例：</p>
<pre><code class="javascript">let i = &#123;
    name = &#39;andy&#39;
&#125;;
function fn(a,b) &#123;
    console.log(this);
    console.log(a + b);
&#125;;
let f = fn.bind(i,1,2);
f();
</code></pre>
</li>
<li><p>bind 的主要应用</p>
<ul>
<li><p>如果有的函数我们不需要立即调用，但是又想改变这个函数内部的 this 指向，这个时候就用 bind</p>
</li>
<li><p>我们有一个按钮，当我们点击之后就禁用这个按钮，3s 之后恢复使用</p>
<pre><code class="javascript">let btn = document.querySelector(&#39;button&#39;);
btn.addEventListener(&#39;click&#39;,function() &#123;
    this.disabled = true;// 禁用按钮
    setTimeout(function () &#123;
        // 定时器对象里面的 this 指向的是 window
        // this.disabled = false;
        this.disabled = false;
    &#125;.bind(this),3000)
&#125;)
</code></pre>
</li>
<li><p>我们有3个按钮，当我们点击哪个就禁用哪个按钮，2s 之后恢复使用</p>
<pre><code class="javascript">let btns = document.querySelectorAll(&#39;button&#39;);
for (let i = 0; i &lt;= btns.length; i++) &#123;
    btns[i].onclick = function() &#123;
        this.disabled = true;
        setTimeout(function() &#123;
            this.disabled = false;
        &#125;.bind(this),2000)
    &#125;
&#125;
</code></pre>
</li>
<li><p>面向对象 Tab 栏 详见 1.4.1</p>
</li>
</ul>
</li>
</ul>
<h4 id="（4）call-apply-bind-总结"><a href="#（4）call-apply-bind-总结" class="headerlink" title="（4）call apply bind 总结"></a>（4）call apply bind 总结</h4><ul>
<li>相同点<ul>
<li>都可以改变函数内部的 this 指向</li>
</ul>
</li>
<li>区别点<ul>
<li>call 和 apply 会调用函数，并且改变函数内部 this 指向</li>
<li>call 和 apply 传递的参数不一样，call 传递参数是 arg1,arg2…形式，apply 必须是数组形式 [arg]</li>
<li>bind 不会调用函数，可以改变函数内部的 this 指向</li>
</ul>
</li>
<li>主要应用场景：<ul>
<li>call 经常用作继承</li>
<li>apply 经常跟数组有关，比如借助于数学内置对象 Math 求最大值 &#x2F; 最小值</li>
<li>bind 不调用函数，但是还想改变函数内部的 this 指向：比如改变定时器内的 this 指向</li>
</ul>
</li>
</ul>
<h2 id="4-3-严格模式"><a href="#4-3-严格模式" class="headerlink" title="4.3 严格模式"></a>4.3 严格模式</h2><h2 id="4-4-高阶函数"><a href="#4-4-高阶函数" class="headerlink" title="4.4 高阶函数"></a>4.4 高阶函数</h2><h2 id="4-5-闭包"><a href="#4-5-闭包" class="headerlink" title="4.5 闭包"></a>4.5 闭包</h2><h3 id="4-5-1-变量作用域"><a href="#4-5-1-变量作用域" class="headerlink" title="4.5.1 变量作用域"></a>4.5.1 变量作用域</h3><ul>
<li>变量根据作用域的不同可以分为两种：全局变量和局部变量<ul>
<li>函数内部可以使用全局变量</li>
<li>函数外部不可以使用局部变量</li>
<li>当函数执行完毕，本作用域内的局部变量会销毁</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-什么是闭包"><a href="#4-5-2-什么是闭包" class="headerlink" title="4.5.2 什么是闭包"></a>4.5.2 什么是闭包</h3><p>&#x3D;&#x3D;闭包&#x3D;&#x3D;（closure）指有权&#x3D;&#x3D;访问&#x3D;&#x3D;另一个函数作用域中&#x3D;&#x3D;变量&#x3D;&#x3D;的&#x3D;&#x3D;函数&#x3D;&#x3D;。简单理解就是，一个作用域可以访问另外一个函数内部的局部变量</p>
<ul>
<li><p>闭包：我们 fun 这个函数作用域 访问了另外一个函数 fn 里面的局部变量</p>
<pre><code class="javascript">function fn() &#123;
    let num = 10;
    function fun() &#123;
        console.log(num);
    &#125;
    fun();
&#125;
fn();
</code></pre>
</li>
</ul>
<h3 id="4-5-3-在-chrome-中调试闭包"><a href="#4-5-3-在-chrome-中调试闭包" class="headerlink" title="4.5.3 在 chrome 中调试闭包"></a>4.5.3 在 chrome 中调试闭包</h3><ol>
<li>打开浏览器，按 F12 键启动 chrome 调试工具。</li>
<li>设置断点。</li>
<li>找到 Scope 选项（Scope 作用域的意思）。</li>
<li>当我们重新刷新页面，会进入断点调试，Scope 里面会有两个参数（global 全局作用域、local 局部作用域）。</li>
<li>当执行到 <code>fn2()</code> 时，Scope 里面会多一个 <code>Closure</code> 参数 ，这就表明产生了闭包。</li>
</ol>
<h3 id="4-5-4-闭包的作用"><a href="#4-5-4-闭包的作用" class="headerlink" title="4.5.4 闭包的作用"></a>4.5.4 闭包的作用</h3><ul>
<li><p>&#x3D;&#x3D;延伸了变量的作用范围&#x3D;&#x3D;</p>
</li>
<li><p>我们 fn 外面的作用域可以访问 fn 内部的局部变量</p>
<pre><code class="javascript">function fn() &#123;
    let num = 10;
    function fun() &#123;
        console.log(num);
    &#125;
    return fun;
&#125;
let f = fn();// fn() 返回的是一个函数 fun()
f();
// 类似于
//let f = function fun() &#123;
//    console.log(num);
//&#125;
</code></pre>
</li>
</ul>
<h3 id="4-5-5-闭包案例"><a href="#4-5-5-闭包案例" class="headerlink" title="4.5.5 闭包案例"></a>4.5.5 闭包案例</h3><blockquote>
<p>以下案例都是在ES5前提下，所以没有提及 let、const</p>
</blockquote>
<h4 id="（1）循环注册点击事件"><a href="#（1）循环注册点击事件" class="headerlink" title="（1）循环注册点击事件"></a>（1）循环注册点击事件</h4><pre><code class="javascript">// 闭包应用-点击li输出索引号
// 1.动态添加属性(用 let 可以解决)
var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;);
for (var i = 0; i &lt; lis.length; i++) &#123;
    lis[i].index = i;
    lis[i].onclick = function() &#123;
        console.log(this.index);
    &#125;
&#125;

// 2.利用闭包的方式得到当前 li 的索引号
for (let i = 0; i &lt; lis.length; i++) &#123;
    // 利用 for 循环创建了4个立即执行函数
    // 立即执行函数也称为小闭包 因为立即执行函数里面的任何一个函数都可以使用它的 i 这变量
    (function(i) &#123;
        // console.log(i);
        lis[i].onclick = function() &#123;
            console.log(i);
        &#125;
    &#125;)(i);
&#125;
</code></pre>
<h4 id="（2）循环中的-setTimeout"><a href="#（2）循环中的-setTimeout" class="headerlink" title="（2）循环中的 setTimeout()"></a>（2）循环中的 setTimeout()</h4><pre><code class="javascript">// 闭包应用 3s 后，打印所有 li 元素的内容
var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;);
for (var i = 0; i &lt; lis.length; i++) &#123;
    (function(i) &#123;
        setTimeout(function() &#123;
            console.log(lis[i].innerHtml);
        &#125;, 3000)
    &#125;)(i)
&#125;
</code></pre>
<h4 id="（3）计算打车价格"><a href="#（3）计算打车价格" class="headerlink" title="（3）计算打车价格"></a>（3）计算打车价格</h4><pre><code class="javascript">// 打车起步价13（3公里内），之后每多一公里增加 5 块钱，用户输入公里数就可以计算打车价格
// 如果有拥堵情况，总价格多收取 10 块钱拥堵费
let car = (function() &#123;
    let start = 13;// 起步价
    let total = 0;// 总价
    return &#123;
        // 正常的总价
        price: function(n) &#123;
            if (n &lt;= 3) &#123;
                total = start;
            &#125; else &#123;
                total = start + (n - 3) * 5;
            &#125;
            return total;
        &#125;,
        // 拥堵之后的费用
        yd: function(flag) &#123;
            return flag ? total + 10 : total;
        &#125;
    &#125;
&#125;)();
console.log(car.price(5));// 23
console.log(car.yd(true));// 33
</code></pre>
<h3 id="4-5-6-闭包总结"><a href="#4-5-6-闭包总结" class="headerlink" title="4.5.6 闭包总结"></a>4.5.6 闭包总结</h3><ul>
<li>闭包是什么<br>闭包是一个函数（一个作用域可以访问另外一个函数的局部变量）。</li>
<li>闭包的作用是什么<br>延伸变量的作用范围。</li>
</ul>
<h2 id="4-6-递归"><a href="#4-6-递归" class="headerlink" title="4.6 递归"></a>4.6 递归</h2><h3 id="4-6-1-什么是递归"><a href="#4-6-1-什么是递归" class="headerlink" title="4.6.1 什么是递归"></a>4.6.1 什么是递归</h3><p>如果 <strong>一个函数在内部可以调用其本身</strong>，那么这个函数就是 <strong>递归函数</strong>。<br>        简单理解:函数内部自己调用自己, 这个函数就是递归函数。<br>递归函数的作用和循环效果一样。</p>
<p>由于递归很容易发生 “栈溢出” 错误（<code>stack overflow</code>），所以必须要加退出条件 <code>return</code>。</p>
<h3 id="4-6-2-递归举例"><a href="#4-6-2-递归举例" class="headerlink" title="4.6.2 递归举例"></a>4.6.2 递归举例</h3><h4 id="（1）求阶乘"><a href="#（1）求阶乘" class="headerlink" title="（1）求阶乘"></a>（1）求阶乘</h4><pre><code class="javascript">let factorial = function(n) &#123;
    if (n == 0 || n == 1) &#123;
        return 1;
    &#125;
    return n * factorial(n - 1)
&#125;
console.log(factorial(3))
</code></pre>
<h4 id="（2）斐波那契数列"><a href="#（2）斐波那契数列" class="headerlink" title="（2）斐波那契数列"></a>（2）斐波那契数列</h4><pre><code class="js">let fibonacci = function(n) &#123;
    if (n &lt; 2) &#123;
        return n;
    &#125;
    return fibonacci(n - 1) + fibonacci(n - 2);
&#125;
console.log(fibonacci(3))
</code></pre>
<h2 id="4-7-浅拷贝和深拷贝"><a href="#4-7-浅拷贝和深拷贝" class="headerlink" title="4.7 浅拷贝和深拷贝"></a>4.7 浅拷贝和深拷贝</h2><ul>
<li>浅拷贝只是拷贝一层, 更深层次对象级别的只拷贝引用（<strong>修改目标对象的值，源对象的值也会改变，因为对象属性指向同一地址</strong>）。</li>
<li>深拷贝拷贝多层，每一级别的数据都会拷贝。</li>
<li><code>Object.assign(target, ...sources)</code> es6 新增方法可以 <strong>浅拷贝</strong>。</li>
</ul>
<h1 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5. 正则表达式"></a>5. 正则表达式</h1><h2 id="5-1-正则表达式概述"><a href="#5-1-正则表达式概述" class="headerlink" title="5.1 正则表达式概述"></a>5.1 正则表达式概述</h2><h3 id="5-1-1-什么是正则表达式"><a href="#5-1-1-什么是正则表达式" class="headerlink" title="5.1.1 什么是正则表达式"></a>5.1.1 什么是正则表达式</h3><ul>
<li><p><strong>正则表达式（ Regular Expression ）</strong>是用于匹配字符串中字符组合的模式。在 JavaScript 中，正则表达式也是&#x3D;&#x3D;对象&#x3D;&#x3D;。</p>
</li>
<li><p>正则表达式通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文（<strong>匹配</strong>）。此外，正则表达式还常用于过滤掉页面内容中的一些敏感词（<strong>替换</strong>），或从字符串中获取我们想要的特定部分（<strong>提取</strong>）等 。</p>
</li>
<li><p>其他语言也会使用正则表达式，本阶段我们主要是利用 JavaScript 正则表达式完成表单验证。</p>
</li>
</ul>
<h3 id="5-1-2-正则表达式的特点"><a href="#5-1-2-正则表达式的特点" class="headerlink" title="5.1.2 正则表达式的特点"></a>5.1.2 正则表达式的特点</h3><ul>
<li><p>灵活性、逻辑性和功能性非常的强。</p>
</li>
<li><p>可以迅速地用极简单的方式达到字符串的复杂控制。</p>
</li>
<li><p>对于刚接触的人来说，比较晦涩难懂。比如： <code>^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</code></p>
</li>
<li><p>实际开发，一般都是直接复制写好的正则表达式。但是要求会使用正则表达式并且根据实际情况修改正则表达式。比如用户名：<code>/^[a-z0-9_-]&#123;3,16&#125;$/</code></p>
</li>
</ul>
<h2 id="5-2-正则表达式在-JavaScript-中的使用"><a href="#5-2-正则表达式在-JavaScript-中的使用" class="headerlink" title="5.2 正则表达式在 JavaScript 中的使用"></a>5.2 正则表达式在 JavaScript 中的使用</h2><h3 id="5-2-1-创建正则表达式"><a href="#5-2-1-创建正则表达式" class="headerlink" title="5.2.1 创建正则表达式"></a>5.2.1 创建正则表达式</h3><p>在 JavaScript 中，可以通过两种方式创建一个正则表达式。</p>
<ul>
<li><p>通过调用 RegExp 对象的构造函数创建</p>
<pre><code class="js">var regexp = new RegExp(/表达式/); Copy to clipboardErrorCopied
</code></pre>
</li>
<li><p>通过字面量创建</p>
<pre><code class="js">var regexp = /表达式/;
</code></pre>
</li>
</ul>
<h3 id="5-2-2-测试正则表达式-text"><a href="#5-2-2-测试正则表达式-text" class="headerlink" title="5.2.2 测试正则表达式 text"></a>5.2.2 测试正则表达式 text</h3><p><code>test()</code> 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 <code>true</code> 或 <code>false</code>，其参数是测试字符串。</p>
<pre><code class="js">regexObj.test(str);Copy to clipboardErrorCopied
</code></pre>
<ul>
<li><code>regexObj</code> 是写的正则表达式</li>
<li><code>str</code> 我们要测试的文本</li>
<li>检测 <code>str</code> 文本是否符合我们写的正则表达式规范</li>
</ul>
<h2 id="5-3-正则表达式中的特殊字符"><a href="#5-3-正则表达式中的特殊字符" class="headerlink" title="5.3 正则表达式中的特殊字符"></a>5.3 正则表达式中的特殊字符</h2><h3 id="5-3-1-正则表达式的组成"><a href="#5-3-1-正则表达式的组成" class="headerlink" title="5.3.1 正则表达式的组成"></a>5.3.1 正则表达式的组成</h3><p>一个正则表达式可以 <strong>由简单的字符构成</strong>，比如 <code>/abc/</code>，也可以是 <strong>简单和特殊字符的组合</strong>，比如 <code>/ab*c/</code> 。其中特殊字符也被称为 <strong>元字符</strong>，在正则表达式中是具有特殊意义的专用符号，如 <code>^</code> 、<code>$</code> 、<code>+</code> 等。</p>
<p>特殊字符非常多，可以参考：</p>
<ul>
<li>MDN：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions</a></li>
<li>正则测试工具: <a target="_blank" rel="noopener" href="http://tool.oschina.net/regex">http://tool.oschina.net/regex</a></li>
</ul>
<p>这里我们把元字符划分几类学习。</p>
<h3 id="5-3-2-边界符"><a href="#5-3-2-边界符" class="headerlink" title="5.3.2 边界符"></a>5.3.2 边界符</h3><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符。</p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>^</code></td>
<td>表示匹配行首的文本（以谁开始）</td>
</tr>
<tr>
<td><code>$</code></td>
<td>表示匹配行尾的文本（以谁结束）</td>
</tr>
</tbody></table>
<p>如果 <code>^</code> 和 <code>$</code> 在一起，表示必须是 <strong>精确匹配</strong>（不能多不能少，只能是这些）。</p>
<pre><code class="js">let regexp = /^he$/;
console.log(regexp.test(&#39;hello&#39;)); // flase
console.log(regexp.test(&#39;he&#39;)); // true
</code></pre>
<h3 id="5-3-3-字符类"><a href="#5-3-3-字符类" class="headerlink" title="5.3.3 字符类"></a>5.3.3 字符类</h3><p>字符类表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p>
<h4 id="（1）-方括号"><a href="#（1）-方括号" class="headerlink" title="（1）[]方括号"></a>（1）<code>[]</code>方括号</h4><pre><code class="js">/[abc]/.test(&#39;andy&#39;)
// true Copy to clipboardErrorCopied
</code></pre>
<p>正则含义：后面的字符串只要包含 <code>abc</code> 中任意一个字符，都返回 <code>true</code>。</p>
<h4 id="（2）-方括号内部-范围符"><a href="#（2）-方括号内部-范围符" class="headerlink" title="（2）[-] 方括号内部 范围符 -"></a>（2）<code>[-]</code> 方括号内部 范围符 <code>-</code></h4><pre><code class="js">/^[a-zA-Z0-9-_]$/.test(&#39;c&#39;)
// true 
</code></pre>
<p>含义：方括号内部加上 <code>-</code> 表示范围，这里表示 <code>a</code> 到 <code>z</code> 、<code>A</code>到<code>Z</code>、<code>0</code>到<code>9</code>、<code>-</code>、<code>_</code>都可以。</p>
<h4 id="（3）-方括号内部-取反符"><a href="#（3）-方括号内部-取反符" class="headerlink" title="（3）[^] 方括号内部 取反符 ^"></a>（3）<code>[^]</code> 方括号内部 取反符 <code>^</code></h4><pre><code class="js">/[^abc]/.test(&#39;andy&#39;)
// falseCopy to clipboardErrorCopied
</code></pre>
<p>方括号内部加上 <code>^</code> 表示 <strong>取反</strong>，只要包含方括号内的字符，都返回 <code>false</code> 。</p>
<blockquote>
<p>&#x3D;&#x3D;注意和边界符 <code>^</code> 区别，边界符写到方括号外面。&#x3D;&#x3D;</p>
</blockquote>
<h4 id="（4）量词符"><a href="#（4）量词符" class="headerlink" title="（4）量词符"></a>（4）量词符</h4><p>量词符用来设定 <strong>某个模式出现的次数</strong>。</p>
<table>
<thead>
<tr>
<th>量词</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>*</code></td>
<td>重复次数 ≥ 0</td>
</tr>
<tr>
<td><code>+</code></td>
<td>重复次数 ≥ 1</td>
</tr>
<tr>
<td><code>?</code></td>
<td>重复 0 次或 1 次</td>
</tr>
<tr>
<td><code>&#123;n&#125;</code></td>
<td>重复 n 次</td>
</tr>
<tr>
<td><code>&#123;n,&#125;</code></td>
<td>重复次数 ≥ n</td>
</tr>
<tr>
<td><code>&#123;n,n&#125;</code></td>
<td>重复 n 次到 m 次</td>
</tr>
</tbody></table>
<h4 id="（5）括号总结"><a href="#（5）括号总结" class="headerlink" title="（5）括号总结"></a>（5）括号总结</h4><ul>
<li>大括号：量词符。里面表示重复次数。</li>
<li>中括号：字符集合。匹配方括号中的任意字符。</li>
<li>小括号：表示优先级。</li>
</ul>
<p>在线测试: <a target="_blank" rel="noopener" href="https://c.runoob.com/">https://c.runoob.com/</a></p>
<h4 id="（6）预定义类"><a href="#（6）预定义类" class="headerlink" title="（6）预定义类"></a>（6）预定义类</h4><table>
<thead>
<tr>
<th>预定类</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>\d</code></td>
<td>匹配 0-9 之间的任一数字，相当于 <code>[0-9]</code></td>
</tr>
<tr>
<td><code>\D</code></td>
<td>匹配所有 0-9 以外的字符，相当于 <code>[^0-9]</code></td>
</tr>
<tr>
<td><code>\w</code></td>
<td>匹配任意的字母、数字和下划线，相当于 <code>[A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>\W</code></td>
<td>除所有字母、数字和下划线以外的字符，相当于 <code>[^A-Za-z0-9_]</code></td>
</tr>
<tr>
<td><code>\s</code></td>
<td>匹配空格（包括换行符、制表符、空格符等），相等于<code>[\t\r\n\v\f]</code></td>
</tr>
<tr>
<td><code>\S</code></td>
<td>匹配非空格的字符，相当于 <code>[^\t\r\n\v\f]</code></td>
</tr>
</tbody></table>
<h4 id="（7）正则案例"><a href="#（7）正则案例" class="headerlink" title="（7）正则案例"></a>（7）正则案例</h4><ul>
<li>手机号码：<code>/^1[3|4|5|7|8][0-9]&#123;9&#125;$/</code></li>
<li>QQ：<code>[1-9][0-9]&#123;4,&#125;</code>（腾讯QQ号从10000开始）</li>
<li>昵称是中文：<code>^[\u4e00-\u9fa5]&#123;2,8&#125;$</code></li>
</ul>
<h2 id="5-4-正则表达式中的替换"><a href="#5-4-正则表达式中的替换" class="headerlink" title="5.4 正则表达式中的替换"></a>5.4 正则表达式中的替换</h2>
  </div>
  <div id="gitalk-container"></div>
</div>

<script>
  
Fancybox.bind('[data-fancybox="fancybox-gallery-img"]', {
  dragToClose: true,
  Toolbar: true,
  closeButton: "top",
  Image: {
    zoom: true,
  },
  on: {
    initCarousel: (fancybox) => {
      const slide = fancybox.Carousel.slides[fancybox.Carousel.page];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
    "Carousel.change": (fancybox, carousel, to, from) => {
      const slide = carousel.slides[to];
      fancybox.$container.style.setProperty(
        "--bg-image",
        `url("${slide.$thumb.src}")`
      );
    },
  },
});
</script>

<style>
    #noneimg img {
        display: none;
        z-index: 9999;
        /* width: 600px !important; */
        min-width: 0%;
        max-width: 90%;
        max-height: 80%;
        border-radius: 0px;
        position: fixed;
        box-shadow: 0 0 0px #c3c3c300 !important;
        left: 0;
        top: 0;
        right: 0;
        bottom: 0;
        margin: auto !important;
    }

    @media screen and (max-width:600px) {
        #noneimg img {
            max-width: 88%
        }
    }
</style>

    <div class="post-paging">
    
    <a href="/2022/11/11/PC%E7%AB%AF%E7%BD%91%E9%A1%B5%E7%89%B9%E6%95%88/">
        <div class="post-paging-last">
            <span>上一篇</span>
            <p>PC端网页特效</p>
        </div>
    </a>
    

    
    <a href="/2022/11/11/Web%20APIs/">
        <div class="post-paging-next">
            <span>下一篇</span>
            <p>Web Apis</p>
        </div>
    </a>
    
</div>
</div>
		
<div class="footer">
	<div class="Copyright">
		©2022 By sheep. 主题：<a
			style="text-decoration: none;display: contents; color: #898F9F;"
			target="_blank" rel="noopener" href="https://github.com/79e/hexo-theme-quiet">Quiet</a>
	</div>
	<div class="contact">
		
		<a target="_blank" rel="noopener" href="https://github.com/79E/hexo-theme-quiet">
			<img src="https://cdn.jsdelivr.net/gh/duogongneng/MyBlogImg/imggithub.png" alt="Quiet主题">
		</a>
		
	</div>
</div>

<script src="/js/gotop.js"></script>


<style type="text/css">
    @media screen and (min-width: 600px) {
        .goTop>span {
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 10px;
            width: 40px;
            height: 40px;
            cursor: pointer;
            opacity: 0.8;
            background: rgba(18, 24, 58, 0.06);
            text-align: center;
            transition: border .5s;
            border: 1px solid rgba(18, 24, 58, 0.06);

            -moz-transition: border .5s;
            /* Firefox 4 */
            -webkit-transition: border .5s;
            /* Safari 和 Chrome */
            -o-transition: border .5s;
            /* Opera */
        }

        .goTop>span:hover {
            border: 1px solid #6680B3;
        }


        .goTop {
            position: fixed;
            right: 30px;
            bottom: 80px;
        }

        .goTop>span>svg {
            width: 20px;
            height: 20px;
            opacity: 0.7;
        }

    }

    @media screen and (max-width: 600px) {
        .goTop {
            display: none;
        }
    }
</style>
<div class="goTop" id="js-go_top">
    <span>
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
            <g>
                <path d="M13 12v8h-2v-8H4l8-8 8 8z"></path>
            </g>
        </svg>
    </span>
</div>
<script>
    $( '#js-go_top' )
	.gotoTop( {
		offset: 500,
		speed: 300,
		animationShow: {
			'transform': 'translate(0,0)',
			'transition': 'transform .5s ease-in-out'
		},
		animationHide: {
			'transform': 'translate(100px,0)',
			'transition': 'transform .5s ease-in-out'
		}
	} );
</script>


<!-- Baidu Analytics -->
<script defer>
    var _hmt = _hmt || [];
    (function () {
        var hm = document.createElement("script");
        hm.src = "https://hm.baidu.com/hm.js?94ea92e08139a609b3e9a9fd82080c82";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>



    <!-- Gitalk -->
    <script>
        const data = '{"clientID":"f9b10e7298e1a0d041ea","clientSecret":"ed9c807b5965710c6636de27d7972668257d348c","repo":"myblogtalk","owner":"sheep1005","admin":"sheep1005"}'
        const gitalk = new Gitalk({
            ...JSON.parse( data),
            id:location.pathname,
            distractionFreeMode:false
        })
        
        if(Boolean('true')){
            gitalk.render('gitalk-container')
        }
    </script>

<script>
	console.log('\n %c Hexo-Quiet 主题 %c https://github.com/79e/hexo-theme-quiet \n', 'color: #fadfa3; background: #030307; padding:5px 0;', 'background: #fadfa3; padding:5px 0;')
</script>
	</body>
</html>

